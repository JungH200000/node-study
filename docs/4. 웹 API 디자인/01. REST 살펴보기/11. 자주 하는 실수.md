## API 설계, 흔하지만 치명적인 실수 4가지 피하기 💣

지금까지 좋은 웹 API를 설계하기 위한 여러 원칙을 알아봤습니다. 하지만 이런 원칙들은 강제성이 없어서, 지키지 않아도 당장 API가 고장 나거나 오류가 발생하지는 않습니다. 바로 이런 점 때문에 자신도 모르는 사이에 실수를 저지르기 쉽습니다.

이번 글에서는 실제 API를 설계할 때 자주 하는 실수들을 살펴보고, 어떻게 개선할 수 있는지 알아보겠습니다.

---

### 실수 1: HTTP 메서드의 역할을 무시한 경우 📮

각 HTTP 메서드는 저마다의 역할(의미)을 가집니다. `GET`은 조회, `POST`는 생성처럼요. 이 약속을 무시하면 API가 예측과 다르게 동작하여 큰 혼란을 줄 수 있습니다.

#### **잘못된 예시 1: `POST`로 데이터 조회하기**

'멤버 목록 조회'는 데이터를 가져오는 것이므로 `GET`을 써야 하지만, `POST`로 구현한 경우입니다.

```http
# 멤버 목록을 조회하는데 POST 메서드를 사용
POST /members
```

#### **잘못된 예시 2: `GET`으로 데이터 생성하기**

'새로운 멤버 생성'은 `POST`를 써야 하지만, 쿼리 파라미터를 이용해 `GET`으로 구현한 경우입니다.

```http
# username=harry 라는 새로운 멤버를 GET으로 생성 시도
GET /members?username=harry
```

- **문제점**
  - **데이터 유실 위험**: 많은 서버 프레임워크는 `GET` 요청의 본문(Body)을 무시하도록 설계되어, 데이터가 정상적으로 처리되지 않을 수 있습니다.
  - **의도치 않은 동작**: `GET` 요청은 브라우저 방문 기록에 남습니다. 사용자가 '뒤로 가기'나 '새로고침'을 할 때마다 의도와 상관없이 데이터가 계속 생성될 수 있습니다.
  - **보안 취약**: 비밀번호와 같은 민감한 정보가 URI에 그대로 노출되어, 서버 로그나 브라우저 기록에 평문으로 남게 됩니다.

---

### 실수 2: 상태 코드로 '거짓말'하는 경우 🚦

상태 코드는 클라이언트에게 요청 처리 결과를 알려주는 핵심적인 신호입니다. 요청이 실패했는데 성공했다는 신호(`200 OK`)를 보내면, 클라이언트는 상황을 오해하고 잘못된 후속 처리를 하게 됩니다.

#### **잘못된 예시: 유효성 검사 실패 후 `200 OK` 응답**

- **요청 (Request)**
  `age` 필드에 유효하지 않은 값(`-10`)을 담아 멤버 생성을 요청합니다.

  ```http
  POST /members
  Content-Type: application/json

  {
    "username": "Harry",
    "age": -10
  }
  ```

- **잘못된 응답 (Response)**
  본문에는 오류 메시지가 있지만, 상태 코드는 성공을 의미하는 `200 OK`를 보냈습니다.

  ```json
  HTTP/1.1 200 OK

  {
    "error": "age must be greater than 0."
  }
  ```

- **문제점**

  - 클라이언트는 보통 상태 코드를 먼저 확인합니다. 상태 코드가 `200`이므로 요청이 성공했다고 착각하고, 오류가 발생했다는 사실을 인지하지 못할 수 있습니다. 이 경우 `400 Bad Request`와 같은 클라이언트 오류 코드를 반환해야 합니다.

---

### 실수 3: 주소(URI)에 행동을 포함시킨 경우 🗺️

URI는 자원(리소스)의 '위치'를 나타내는 **명사**여야 합니다. 자원에 대한 '행동'은 `POST`, `PUT`, `DELETE` 같은 **HTTP 메서드(동사)** 로 표현해야 합니다.

- **Bad ❌**

  ```
  /create-members
  /update-members/1
  /delete-members/2
  ```

- **Good ✅**

  ```
  POST /members
  PUT /members/1
  DELETE /members/2
  ```

---

### 실수 4: 데이터의 '종류'를 알려주지 않는 경우 (MIME Type 누락) 🏷️

요청과 응답의 본문(Body)에 데이터가 담겨 있다면, 그 데이터가 어떤 형식(JSON, XML, TEXT 등)인지 `Content-Type` 헤더를 통해 명확히 알려주어야 합니다.

이 약속이 없다면 서버나 클라이언트는 서로가 보낸 데이터를 어떻게 해석해야 할지 몰라 오류를 일으킬 수 있습니다.

- **올바른 요청/응답 예시**
  본문이 JSON 형식이므로, `Content-Type` 헤더에 `application/json`을 명시해야 합니다.

  ```http
  # 요청 시
  POST /members
  Content-Type: application/json

  {
    "name": "Harry"
  }

  # 응답 시
  HTTP/1.1 201 Created
  Content-Type: application/json

  {
    "id": 2,
    "name": "Harry"
  }
  ```

---

### ✍️ 마무리하며

이번 글에서 살펴본 네 가지 실수는 API가 당장 동작하지 않게 만드는 치명적인 버그는 아닐 수 있습니다. 하지만 이런 실수들이 쌓이면, API를 사용하는 다른 개발자들에게 혼란을 주고 예측하기 어려운 시스템을 만들게 됩니다.

- **HTTP 메서드**는 **역할**에 맞게,
- **상태 코드**는 **결과**에 맞게,
- **URI**는 **자원(명사)** 만 표현하도록,
- **`Content-Type`** 으로 데이터의 **종류**를 명시하도록

이 네 가지 기본 원칙만 잘 지켜도 훨씬 더 안정적이고 누구나 쉽게 사용할 수 있는 좋은 API를 설계할 수 있을 겁니다.
