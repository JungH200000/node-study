## API 성능 최적화의 비밀: HTTP 캐싱 똑똑하게 사용하기 🧠

서버는 수많은 클라이언트로부터 끊임없이 요청(Request)을 받습니다. 그런데 만약 여러 클라이언트가 **동일하고, 변경되지 않은 데이터**를 반복해서 요청한다면 어떨까요? 서버는 똑같은 데이터를 계속해서 보내주어야 하고, 이는 서버와 클라이언트 모두에게 불필요한 시간과 자원 낭비입니다.

마치 도서관에서 어제 빌렸던 책을 오늘 또 빌리러 가는 것과 같죠. 어차피 내용이 똑같다면, 집에 있는 책을 다시 보면 될 텐데 말입니다.

이러한 낭비를 줄이기 위해 **캐싱(Caching)** 이라는 기술을 사용합니다. **캐시(Cache)** 란 한 번 받아온 데이터를 재사용하기 위해 임시로 저장해두는 장소를 의미하며, REST의 중요한 제약 조건 중 하나입니다.

HTTP에서는 헤더를 이용해 이 캐싱을 아주 스마트하게 제어할 수 있습니다. 캐싱 전략은 크게 두 가지로 나뉩니다.

- **유효기간 전략**: "이 데이터는 1분 동안 유효하니, 1분 안에는 나한테 다시 물어보지 마\!"
- **재검증 전략**: "혹시 내가 가진 데이터가 여전히 최신 버전인지 확인만 해줘\!"

---

### 전략 1: 유효기간 설정하기 (`Cache-Control`)

가장 기본적인 캐싱 방법은 데이터에 **유효기간**을 설정하는 것입니다. `Cache-Control` 헤더의 `max-age` 값을 사용하면 "이 데이터가 몇 초 동안 유효한지"를 클라이언트에게 알려줄 수 있습니다.

#### **최초 요청**

클라이언트가 처음으로 프로필 이미지를 요청합니다.

```http
GET /members/1/profile
```

#### **최초 응답**

서버는 이미지 데이터와 함께, 이 데이터가 **60초간 유효**하다는 `Cache-Control` 헤더를 보냅니다. 클라이언트는 이 응답을 캐시에 저장합니다.

```http
HTTP/1.1 200 OK
Content-Type: image/png
Cache-Control: max-age=60

(10MB 이미지 데이터)
```

#### **60초 이내의 후속 요청**

클라이언트는 60초가 지나기 전까지는 서버에 요청을 보내지 않고, 자신이 저장해 둔 **캐시에서 직접 이미지를 가져와 사용**합니다. 네트워크 통신이 전혀 발생하지 않아 매우 빠릅니다.

---

### 전략 2: 데이터가 바뀌었는지 물어보기 (재검증)

`max-age`로 지정한 유효기간이 지나면 캐시는 만료됩니다. 이때 클라이언트는 서버에 **"혹시 데이터가 그 사이에 변경되었니?"** 라고 물어보고, 변경되지 않았다면 기존 캐시 데이터를 재사용할 수 있습니다. 이 '재검증' 과정에는 두 가지 방법이 있습니다.

#### 방법 A: 마지막 수정일로 검증하기 (`Last-Modified` / `If-Modified-Since`)

데이터가 마지막으로 수정된 날짜를 기준으로 변경 여부를 확인하는 방법입니다.

#### **최초 응답 (수정 날짜 포함)**

서버가 데이터와 함께 데이터가 마지막으로 수정된 날짜 정보(`Last-Modified`)를 함께 보내줍니다.

```http
HTTP/1.1 200 OK
Content-Type: image/png
Cache-Control: max-age=60
Last-Modified: Mon, 08 Sep 2025 10:00:00 GMT

(10MB 이미지 데이터)
```

#### **캐시 만료 후 재검증 요청**

60초가 지나 캐시가 만료되면, 클라이언트는 자신이 기억하고 있는 수정 날짜를 `If-Modified-Since` 헤더에 담아 서버에 물어봅니다.

```http
GET /members/1/profile
If-Modified-Since: Mon, 08 Sep 2025 10:00:00 GMT
```

#### **재검증 응답 (변경 없음)**

서버는 클라이언트가 보내준 날짜와 실제 파일의 수정 날짜를 비교합니다. 만약 변경된 내용이 없다면, **`304 Not Modified`** 라는 상태 코드와 함께 **본문(Body) 없이 헤더만** 보냅니다.

```http
HTTP/1.1 304 Not Modified
Cache-Control: max-age=60
Last-Modified: Mon, 08 Sep 2025 10:00:00 GMT

(본문 없음)
```

클라이언트는 이 응답을 받고, "아, 내가 가진 데이터가 여전히 최신이구나\!"라고 판단하여 캐시된 10MB 이미지 데이터를 재사용하고, 캐시의 유효기간을 다시 60초로 갱신합니다.

---

#### 방법 B: 데이터 고유 식별자로 검증하기 (`ETag` / `If-None-Match`)

`Last-Modified`는 1초 미만의 정밀한 제어가 어렵고, 파일 내용은 그대로인데 수정 시간만 바뀌는 경우에도 데이터가 변경되었다고 착각하는 한계가 있습니다.

이런 단점을 보완하기 위해 **`ETag`** 를 사용합니다. `ETag`는 해당 데이터의 버전을 나타내는 고유한 식별자(마치 파일의 지문이나 해시값)입니다. 데이터 내용이 조금이라도 바뀌면 `ETag` 값도 함께 변경됩니다.

#### **최초 응답 (ETag 포함)**

```http
HTTP/1.1 200 OK
Content-Type: image/png
Cache-Control: max-age=60
ETag: "xyz-123-abc-789"

(10MB 이미지 데이터)
```

#### **캐시 만료 후 재검증 요청**

캐시 만료 후, 클라이언트는 자신이 기억하는 `ETag` 값을 `If-None-Match` 헤더에 담아 서버에 물어봅니다.

```http
GET /members/1/profile
If-None-Match: "xyz-123-abc-789"
```

#### **재검증 응답 (변경 없음)**

서버는 현재 데이터의 `ETag`와 클라이언트가 보낸 `ETag`를 비교합니다. 값이 같다면, `Last-Modified` 때와 마찬가지로 `304 Not Modified` 응답을 보냅니다.

```http
HTTP/1.1 304 Not Modified
Cache-Control: max-age=60
ETag: "xyz-123-abc-789"

(본문 없음)
```

`ETag`는 날짜 기반 방식보다 더 정교하게 데이터의 변경 여부를 감지할 수 있어 더 권장되는 방식입니다.

---

### ✍️ 마무리하며

HTTP 캐싱은 API의 성능을 극대화하고 불필요한 네트워크 트래픽을 줄이는 핵심적인 기능입니다.

- **`Cache-Control`** 헤더로 캐시의 **유효기간**을 정해 불필요한 요청을 막고,
- 유효기간이 만료된 후에는 **`Last-Modified`** 나 **`ETag`** 같은 **재검증** 헤더를 통해 데이터가 변경되지 않았다면 전체 데이터를 다시 다운로드하는 낭비를 막을 수 있습니다.

이러한 캐싱 헤더들은 독립적으로 사용되기보다, `Cache-Control`과 `ETag`를 함께 사용하는 것처럼 **상황에 맞춰 서로를 보완하며 사용**됩니다. 상황에 맞는 적절한 캐싱 전략을 사용하는 것이 좋은 API를 만드는 중요한 열쇠 중 하나입니다.
