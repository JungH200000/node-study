## 🛡️ 서버가 죽지 않게\! 비동기 코드 에러 처리하기

이전에 유효성 검사(Validation)에 실패하는 요청을 보냈을 때, 서버가 응답 없이 멈춰버리는 문제를 확인했습니다. `Task.create()`, `Task.findById()`처럼 데이터베이스와 통신하는 **비동기 작업 도중 발생하는 오류를 제대로 처리해주지 않았기 때문**입니다.

이런 비동기 오류는 다양한 상황에서 발생할 수 있습니다.

- **유효성 검사 실패**: Mongoose 스키마 규칙에 맞지 않는 데이터를 생성/수정하려 할 때 (`ValidationError`)
- **잘못된 ID 형식**: MongoDB의 `ObjectId` 형식이 아닌 ID로 데이터를 조회하려 할 때 (`CastError`)
- **네트워크 문제**: 일시적인 네트워크 불안정으로 데이터베이스 연결이 끊겼을 때

사용자의 잘못된 요청이나 일시적인 오류 때문에 서버 전체가 멈추는 것은 매우 심각한 문제입니다. 모든 라우트 핸들러의 `await` 코드를 `try...catch` 문으로 감싸는 방법도 있지만, 모든 라우트에 반복적으로 코드를 작성해야 해서 비효율적입니다.

더 우아하고 효율적인 해결책은 바로, **에러 처리 로직을 담은 헬퍼(Helper) 함수**를 만드는 것입니다.

### 1. 에러 처리의 해결사, `asyncHandler` 함수 만들기

모든 비동기 라우트 핸들러를 감싸서 에러를 대신 처리해 줄 `asyncHandler` 함수를 만들어 보겠습니다.

```javascript
// /app.js

function asyncHandler(handler) {
  return async function (req, res) {
    try {
      await handler(req, res);
    } catch (e) {
      // 에러 처리 로직
      res.status(500).send({ message: 'Server Error' }); // 우선 기본 에러 처리
    }
  };
}
```

`asyncHandler` 함수를 각 라우트에 아래와 같이 적용합니다.

**[적용 전]**

```javascript
app.post('/tasks', async (req, res) => {
  const newTask = await Task.create(req.body);
  res.status(201).send(newTask);
});
```

**[적용 후]**

```javascript
app.post(
  '/tasks',
  asyncHandler(async (req, res) => {
    const newTask = await Task.create(req.body);
    res.status(201).send(newTask);
  })
);
```

---

### 🕵️‍♂️ `asyncHandler`는 어떻게 동작할까요?

`asyncHandler`는 **고차 함수(Higher-Order Function)** 입니다. 말이 조금 어렵지만, 간단히 말해 **'다른 함수를 인자로 받거나, 함수를 결과로 반환하는 함수'** 를 의미합니다. `asyncHandler`는 이 두 가지를 모두 하고 있죠.

1.  **함수를 인자로 받는다**: `asyncHandler`는 우리가 작성한 기존의 라우트 핸들러 함수(`async (req, res) => { ... }`)를 `handler`라는 이름의 인자로 받습니다.

2.  **새로운 함수를 반환한다**: 그리고 `try...catch` 로직이 추가된 **새로운 핸들러 함수**를 반환합니다. Express는 바로 이 새로 반환된 함수를 실제 라우트 핸들러로 사용하게 됩니다.

3.  **`try...catch`로 감싸서 실행**:

    - **`try` 블록**: `asyncHandler`는 내부에서 우리가 전달한 원래의 핸들러(`handler`)를 `await handler(req, res)` 코드로 실행합니다. 만약 원래 핸들러가 문제없이 성공하면, 여기서 모든 로직이 정상적으로 처리됩니다.
    - **`catch` 블록**: 만약 `await handler(req, res)`를 실행하는 도중 **어떤 종류의 비동기 오류라도 발생하면**, `try...catch` 문이 이 오류를 붙잡습니다(`catch(e)`). 오류가 잡혔기 때문에 서버는 더 이상 멈추지 않고, `catch` 블록 안의 에러 처리 로직을 실행하게 됩니다.

결론적으로 `asyncHandler`는 우리가 만든 비동기 핸들러 함수에게 **에러가 발생해도 서버를 멈추지 않게 해주는 안전망**을 씌워주는 역할을 합니다.

---

### 2. 오류 종류에 따라 다른 응답 보내기

이제 `catch` 블록을 더 똑똑하게 만들어, 발생한 오류의 종류(`e.name`)에 따라 다른 HTTP 상태 코드와 메시지를 보내도록 수정해 보겠습니다.

| 오류 이름             | HTTP 상태 코드              | 의미                                                                     |
| :-------------------- | :-------------------------- | :----------------------------------------------------------------------- |
| **`ValidationError`** | `400 Bad Request`           | 사용자가 보낸 데이터가 스키마 유효성 검사를 통과하지 못함. (사용자 잘못) |
| **`CastError`**       | `404 Not Found`             | 잘못된 형식의 ID로 데이터를 조회하여 Mongoose가 변환에 실패함.           |
| **그 외 모든 오류**   | `500 Internal Server Error` | 데이터베이스 연결 문제 등 예측하지 못한 서버 내부의 오류.                |

```javascript
// /app.js - 최종 asyncHandler

function asyncHandler(handler) {
  return async function (req, res) {
    try {
      await handler(req, res);
    } catch (e) {
      if (e.name === 'ValidationError') {
        res.status(400).send({ message: e.message });
      } else if (e.name === 'CastError') {
        // CastError는 주로 잘못된 형식의 ID로 조회할 때 발생합니다.
        // 이 경우 '찾을 수 없음'을 의미하는 404를 보내는 것이 자연스럽습니다.
        res.status(404).send({ message: 'Cannot find given id.' });
      } else {
        res.status(500).send({ message: e.message });
      }
    }
  };
}
```

### 3. 모든 비동기 라우트에 `asyncHandler` 적용하기

이제 `GET` 라우트를 포함하여 `await`를 사용하는 모든 비동기 라우트에 `asyncHandler`를 적용합니다.

```javascript
// /app.js

// ... (다른 코드 생략)

app.get(
  '/tasks',
  asyncHandler(async (req, res) => {
    const { sort, count } = req.query;
    const sortOption = { createdAt: sort === 'oldest' ? 'asc' : 'desc' };
    const tasks = await Task.find().sort(sortOption).limit(count);
    res.send(tasks);
  })
);

app.get(
  '/tasks/:id',
  asyncHandler(async (req, res) => {
    const id = req.params.id;
    const task = await Task.findById(id);

    if (task) {
      res.send(task);
    } else {
      res.status(404).send({ message: 'Cannot find given id.' });
    }
  })
);

app.post(
  '/tasks',
  asyncHandler(async (req, res) => {
    const newTask = await Task.create(req.body);
    res.status(201).send(newTask);
  })
);

// ... (PATCH, DELETE 라우트는 DB 연동 후 마저 수정)
```

### ✅ 최종 테스트

이제 잘못된 요청을 보내도 서버가 멈추지 않고, 우리가 설정한 상태 코드와 에러 메시지를 정확하게 응답하는 것을 확인할 수 있습니다.

**[유효성 검사 실패 시]**
`POST /tasks` (title이 1글자인 경우)
→ `400 Bad Request`와 함께 `title`이 너무 짧다는 에러 메시지 응답

**[잘못된 ID 형식으로 조회 시]**
`GET /tasks/123`
→ `404 Not Found`와 함께 `Cannot find given id.` 메시지 응답

이렇게 비동기 에러를 중앙에서 처리하면, 각 라우트 핸들러는 성공했을 때의 로직에만 집중할 수 있어 코드가 훨씬 깔끔하고 안정적으로 변합니다. 🎉
