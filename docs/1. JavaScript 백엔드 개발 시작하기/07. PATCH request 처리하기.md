## ✍️ 데이터의 일부만 수정해요: PATCH 요청 처리 가이드

웹 서비스를 운영하다 보면 기존 데이터의 일부만 수정해야 할 때가 많습니다. 예를 들어, 할 일(Task)의 완료 상태를 `false`에서 `true`로 바꾸거나, 제목만 살짝 변경하는 경우죠.

이렇게 **기존 리소스의 일부를 수정**할 때 사용하는 것이 바로 **`PATCH`** HTTP 메소드입니다.

### 1. PATCH 요청(Request)은 어떻게 보낼까요?

먼저, ID가 1인 할 일의 `isComplete` 상태를 `true`로 변경하는 `PATCH` 요청을 작성해 보겠습니다.

```http
PATCH http://localhost:3000/tasks/1
Content-Type: application/json

{
  "isComplete": true
}
```

- **`PATCH http://localhost:3000/tasks/1`**: 어떤 리소스(`tasks/1`)를 수정할지 URL 파라미터로 명확히 지정하고, `PATCH` 메소드를 사용합니다.
- **`Content-Type: application/json`**: 요청 본문(Body)에 담긴 데이터 형식이 JSON임을 알려줍니다.
- **`{ "isComplete": true }`**: **수정하고 싶은 필드와 값만** 본문에 담아 보냅니다. `title`이나 다른 내용은 보내지 않았으므로, 서버는 `isComplete` 상태만 변경해야 합니다.

### 2. Express로 PATCH 라우트 만들기

이제 서버에서 이 요청을 받아 처리하는 코드를 `app.js`에 추가해 봅시다.

#### 💻 전체 코드

`app.patch('/tasks/:id', ...)` 라우트 핸들러를 추가한 전체 코드는 다음과 같습니다.

```js
// node01-start-javascript-backend/todo-api/app.js
import express from 'express';
import tasks from './data/mock.js';

const app = express();
app.use(express.json());

// --- GET, POST 라우트 (이전과 동일) ---
app.get('/tasks', (req, res) => {
  // ... (생략)
});

app.get('/tasks/:id', (req, res) => {
  // ... (생략)
});

app.post('/tasks', (req, res) => {
  // ... (생략)
});

// --- 특정 할 일의 정보 수정하기 ---
app.patch('/tasks/:id', (req, res) => {
  // 1. URL 파라미터에서 수정할 task의 id를 가져옵니다.
  const id = Number(req.params.id);
  const task = tasks.find((task) => task.id === id);

  // 2. 해당 id를 가진 task가 존재하는지 확인합니다.
  if (task) {
    // 3. 존재한다면, 요청 본문(req.body)의 내용을 기존 task 객체에 덮어씌웁니다.
    //    Object.keys()와 forEach를 사용해 요청 본문에 있는 모든 키에 대해 반복합니다.
    Object.keys(req.body).forEach((key) => {
      // ex) key가 'isComplete'라면, task['isComplete'] = req.body['isComplete'] 가 됩니다.
      task[key] = req.body[key];
    });

    // 4. 수정한 시간을 기록하고, 업데이트된 task를 클라이언트에 응답으로 보냅니다.
    task.updatedAt = new Date();
    res.send(task);
  } else {
    // 2-1. 존재하지 않는다면, 404 Not Found 에러를 응답합니다.
    res.status(404).send({ message: 'Cannot find given id.' });
  }
});

app.listen(3000, () => {
  console.log('Server started on port 3000');
  console.log(`http://localhost:3000`);
});
```

#### ✨ 핵심 로직 파헤치기

`PATCH` 요청 처리의 핵심은 기존 데이터에 새로운 데이터를 유연하게 덮어쓰는 것입니다.

```javascript
Object.keys(req.body).forEach((key) => {
  task[key] = req.body[key];
});
```

- `Object.keys(req.body)`: 요청 본문 객체(`{ "isComplete": true }`)의 키(key)들을 배열로 만듭니다. `['isComplete']`
- `.forEach((key) => ...)`: 이 배열을 순회하면서 각 키에 대해 함수를 실행합니다.
- `task[key] = req.body[key]`: `task` 객체의 속성을 동적으로 업데이트합니다. `key`가 `'isComplete'`라면, `task.isComplete`의 값을 `req.body.isComplete`의 값(`true`)으로 변경합니다.

이 로직 덕분에 클라이언트가 `title`만 보내면 `title`만 바뀌고, `isComplete`와 `description`을 함께 보내면 두 필드 모두가 업데이트되는 유연한 API가 만들어집니다.

### 3. 실행 결과 확인하기

서버를 실행하고 `PATCH` 요청을 보내서 데이터가 정말 수정되는지 확인해 봅시다.

#### PATCH 요청 전 (ID: 1)

`isComplete`가 `false`인 상태입니다.
\!

#### `PATCH /tasks/1` 요청 및 응답

ID가 1인 할 일의 `isComplete`를 `true`로 변경하는 요청을 보냅니다. 서버는 성공적으로 처리한 후 `200 OK` 상태 코드와 함께 변경된 객체를 응답으로 보내줍니다.

**[요청]**

```http
PATCH http://localhost:3000/tasks/1
Content-Type: application/json

{
  "isComplete": true
}
```

**[응답]**

```json
HTTP/1.1 200 OK
// ...

{
  "id": 1,
  "title": "30분 운동",
  "isComplete": true, // false에서 true로 변경됨
  "createdAt": "2023-03-23T06:34:07.617Z",
  "updatedAt": "2025-08-21T07:14:15.612Z" // 수정된 시간으로 변경됨
}
```

#### PATCH 요청 후

다시 `GET http://localhost:3000/tasks`로 전체 목록을 조회하면, ID가 1인 할 일의 `isComplete`가 `true`로 완전히 변경된 것을 확인할 수 있습니다.

### 💡 알아두면 좋은 점

- **코드 중복**: `GET /tasks/:id`와 `PATCH /tasks/:id`에서 특정 ID의 `task`를 찾는 코드가 중복됩니다. Express의 라우팅 기능을 더 깊게 배우면 이런 중복을 더 깔끔하게 처리할 수 있습니다.
- **데이터 지속성**: 현재는 메모리에 있는 `mock.js` 배열을 사용하고 있기 때문에, 서버를 재시작하면 수정했던 모든 내용이 초기화됩니다. 이 문제는 나중에 데이터베이스(DB)를 연동하면 자연스럽게 해결됩니다.

이제 여러분의 API 서버는 데이터를 읽고, 생성하고, 수정하는 대부분의 핵심 기능을 갖추게 되었습니다\! 🎉
