## 🔍 실제 데이터베이스에서 데이터 조회하기 (GET)

지금까지는 미리 만들어둔 `mock.js` 파일의 임시 데이터를 사용했지만, 이제는 MongoDB 데이터베이스에 직접 연결하여 데이터를 조회하도록 API를 업그레이드해 보겠습니다. `async/await`와 Mongoose의 강력한 쿼리 메소드를 사용하는 방법을 알아봅시다.

### 1단계: 사전 준비

#### 1\. Task 모델 불러오기

`app.js` 파일에서 `Task` 모델을 `import` 합니다.

```javascript
// /app.js
import express from 'express';
import mongoose from 'mongoose';
import dotenv from 'dotenv';
import Task from './models/Task.js';
// 기존 mock 데이터 import
import mockTasks from './data/mock.js';
```

#### 2\. 기존 mock 데이터 변수 이름 변경

코드의 혼동을 막기 위해, 기존에 `tasks`라고 불렀던 mock 데이터 배열의 이름을 `mockTasks`로 변경해 줍니다. (VS Code에서 변수명 위에 커서를 두고 `F2` 키를 누르면 파일 전체에서 한 번에 변경할 수 있습니다.)

---

### 2단계: `GET /tasks/:id` 라우트 수정하기 (특정 데이터 조회)

먼저, 특정 ID를 가진 할 일 하나를 조회하는 라우트부터 데이터베이스를 사용하도록 바꿔보겠습니다.

#### 📜 수정 전 (Before)

```javascript
app.get('/tasks/:id', (req, res) => {
  const id = Number(req.params.id);
  const task = mockTasks.find((task) => task.id === id);

  if (task) {
    res.send(task);
  } else {
    res.status(404).send({ message: 'Cannot find given id.' });
  }
});
```

#### ✨ 수정 후 (After)

```javascript
app.get('/tasks/:id', async (req, res) => {
  // 1. URL 파라미터에서 id를 가져옵니다. MongoDB의 _id는 문자열이므로 Number() 변환이 필요 없습니다.
  const id = req.params.id;

  // 2. Mongoose의 findById 메소드로 특정 id의 데이터를 조회합니다.
  //    DB 조회는 시간이 걸리는 비동기 작업이므로 async/await를 사용합니다.
  const task = await Task.findById(id);

  // 3. 데이터를 찾았다면 클라이언트에 전송하고, 없다면 404 에러를 보냅니다.
  if (task) {
    res.send(task);
  } else {
    res.status(404).send({ message: 'Cannot find given id.' });
  }
});
```

- `async/await`: 데이터베이스 조회는 비동기 작업이므로, `async` 키워드를 핸들러 함수에 추가하고, `Task.findById(id)`의 결과를 기다리기 위해 `await`를 사용합니다.
- `Task.findById(id)`: Mongoose가 제공하는, ID로 데이터를 매우 편리하게 조회할 수 있는 메소드입니다. 만약 해당 ID의 데이터가 없으면 `null`을 반환합니다.

---

### 3단계: `GET /tasks` 라우트 수정하기 (전체 데이터 조회)

이제 할 일 전체 목록을 조회하고, 정렬(sort) 및 개수 제한(count) 쿼리 파라미터를 처리하는 로직을 수정해 보겠습니다.

#### 📜 수정 전 (Before)

```javascript
app.get('/tasks', (req, res) => {
  const { sort, count: countStr } = req.query;
  const count = Number(countStr);

  const compareFn = /* ... JavaScript 정렬 로직 ... */;
  let newTasks = [...mockTasks].sort(compareFn);

  if (count) {
    newTasks = newTasks.slice(0, count);
  }
  res.send(newTasks);
});
```

#### ✨ 수정 후 (After)

```javascript
app.get('/tasks', async (req, res) => {
  const { sort, count } = req.query;

  // 1. 정렬 옵션을 Mongoose 형식에 맞게 객체로 만듭니다.
  const sortOption = { createdAt: sort === 'oldest' ? 'asc' : 'desc' };

  // 2. find(), sort(), limit() 메소드를 체인 형태로 연결하여 쿼리를 작성합니다.
  const tasks = await Task.find().sort(sortOption).limit(count);

  // 3. 조회된 데이터를 클라이언트에 전송합니다.
  res.send(tasks);
});
```

- `Task.find()`: 여러 데이터를 조회하는 메소드입니다. 인자 없이 호출하면 모든 데이터를 가져옵니다.
- **.sort(sortOption)**: 조회된 결과를 정렬합니다. `{ 필드명: 'asc' }` (오름차순) 또는 `{ 필드명: 'desc' }` (내림차순) 형태의 객체를 인자로 받습니다.
- **.limit(count)**: 조회된 결과의 개수를 제한합니다. `count` 변수가 `undefined`이거나 유효하지 않은 숫자여도 Mongoose가 유연하게 처리해 줍니다.

> **🔗 Mongoose 쿼리 체이닝(Query Chaining)** > `find()`, `sort()`, `limit()` 같은 Mongoose의 쿼리 메소드들은 자기 자신(Query 객체)을 반환하기 때문에, 위 코드처럼 점(.)을 찍어 계속 연결(chaining)할 수 있습니다. 이를 통해 복잡한 데이터베이스 조회 조건을 간결하고 읽기 쉽게 작성할 수 있습니다.

---

### ✅ API 테스트 및 결과 확인

이제 Postman이나 REST Client를 사용해 API가 데이터베이스와 잘 연동되는지 테스트해 봅시다.

#### 1\. 전체 목록 조회 (최신순)

`GET http://localhost:3000/tasks`

#### 2\. 오래된 순 3개만 조회

`GET http://localhost:3000/tasks?sort=oldest&count=3`

#### 3\. 특정 ID로 조회

`GET http://localhost:3000/tasks/68a7efff0b4c24193c10d093` (ID는 실제 데이터의 `_id` 값으로 변경)

#### 4\. 없는 ID로 조회

`GET http://localhost:3000/tasks/68a7efff0b4c24193c10d090`
→ `{ "message": "Cannot find given id." }` 404 응답이 오면 성공\!

이제 여러분의 API는 임시 데이터가 아닌, 실제 데이터베이스에서 데이터를 가져오는 멋진 API가 되었습니다\! 🎉

---

### 📚 참고 자료

- **Mongoose Queries**: [https://mongoosejs.com/docs/queries.html](https://mongoosejs.com/docs/queries.html)
- **Mongoose Query API**: [https://mongoosejs.com/docs/api/query.html](https://mongoosejs.com/docs/api/query.html)
