## 🧰 Express 내장 미들웨어: 미리 준비된 만능 도구들

Express로 서버를 만들다 보면, JSON 형식의 요청 본문(body)을 해석하거나, HTML 폼(form) 데이터를 처리하거나, 이미지 파일을 클라이언트에게 보여주는 등 아주 흔하고 반복적인 작업들을 마주하게 됩니다.

Express는 이런 필수 기능들을 개발자가 매번 직접 구현할 필요가 없도록, 미리 잘 만들어진 미들웨어들을 함께 제공합니다. 이를 **내장 미들웨어(Built-in Middleware)** 라고 부릅니다.

이 미들웨어들은 대부분 특정 경로가 아닌, 서버로 들어오는 **모든 요청**에 대해 공통적으로 적용되는 경우가 많습니다. 따라서 보통 아래와 같이 `app.use()`에 바로 연결하여 사용합니다.

```javascript
// 서버 전체에 적용할 미들웨어를 연결하는 일반적인 형태
app.use(express.middleware());
```

가장 대표적인 내장 미들웨어 세 가지를 하나씩 살펴보겠습니다.

---

### 1. `express.json()`

클라이언트가 서버로 `Content-Type: application/json` 형태의 데이터를 보낼 때, 그 요청 본문(body)을 해석하여 `req.body` 객체에 넣어주는 역할을 합니다. API 서버를 만든다면 거의 필수적으로 사용되는 미들웨어입니다.

#### 미들웨어가 없다면?

`express.json()` 미들웨어 없이 `POST` 요청을 보내면, Express는 요청 본문을 어떻게 해석해야 할지 몰라 `req.body`는 `undefined`가 됩니다.

```javascript
// src/app.js
import express from 'express';

const app = express();
const PORT = 3000;

app.post('/products', (req, res) => {
  // express.json()이 없으면 req.body는 undefined가 됩니다.
  console.log(req.body);
  res.json({ message: 'Product 추가하기' });
});

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

```http
POST http://localhost:3000/products
Content-Type: application/json

{
  "name": "상품 1",
  "price": 10000
}
```

**터미널 결과:** `undefined`

#### `express.json()` 적용 후

이제 라우트보다 위쪽에 `app.use(express.json());`을 추가해 봅시다.

```javascript
// src/app.js
import express from 'express';

const app = express();
const PORT = 3000;

// 이 미들웨어가 application/json 형식의 요청 본문을 req.body로 파싱해줍니다.
app.use(express.json());

app.post('/products', (req, res) => {
  // 이제 req.body에서 JSON 데이터를 정상적으로 사용할 수 있습니다.
  console.log(req.body);
  res.json({ message: 'Product 추가하기' });
});

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

**터미널 결과:** `{ name: '상품 1', price: 10000 }`

> **💡 잠깐\! `express.json()`은 함수 아닌가요?**
> 맞습니다. `express.json()`을 호출하면, 그 **실행 결과로 미들웨어 함수가 반환**됩니다. `app.use()`는 바로 그 반환된 함수를 인자로 받아 사용하는 것입니다.

---

### 2. `express.urlencoded()`

주로 HTML `<form>` 태그를 통해 제출되는 `Content-Type: application/x-www-form-urlencoded` 형식의 데이터를 해석하여 `req.body` 객체에 넣어주는 역할을 합니다.

`express.json()`과 마찬가지로, 이 미들웨어가 없으면 폼 데이터는 `req.body`에 담기지 않습니다.

```javascript
// src/app.js
import express from 'express';

const app = express();
const PORT = 3000;

// JSON과 URL-encoded 형식의 요청 본문을 모두 처리하도록 두 미들웨어를 등록합니다.
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.post('/users', (req, res) => {
  console.log(req.body);
  res.json({ message: 'User 추가하기' });
});

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

```http
POST http://localhost:3000/users
Content-Type: application/x-www-form-urlencoded

name=jung&age=32
```

**터미널 결과:** `{ name: 'jung', age: '32' }`

`{ extended: true }` 옵션은 URL-encoded 데이터에 객체나 배열 같은 복잡한 구조가 포함되어 있을 때도 잘 해석할 수 있도록 해주는 설정입니다. 특별한 이유가 없다면 `true`로 설정하는 것이 좋습니다.

---

### 3. `express.static()`

서버의 특정 폴더를 '정적 파일(static files)'을 위한 공간으로 외부에 공개하는 역할을 합니다. 정적 파일이란 이미지, CSS 파일, HTML 파일처럼 서버가 별도의 처리 없이 클라이언트에게 그대로 제공하는 파일을 의미합니다.

예를 들어, 프로젝트에 `public`이라는 폴더를 만들고 그 안에 이미지 파일(`two_cat.png`)과 HTML 파일(`index.html`)을 넣었다고 가정해 봅시다.

```javascript
// src/app.js
import express from 'express';

const app = express();
const PORT = 3000;

// 'public' 폴더를 정적 파일 제공 폴더로 설정합니다.
app.use(express.static('public'));

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

이제 서버를 실행하고 브라우저나 API 테스트 도구에서 아래 주소로 요청을 보내면, `public` 폴더 안의 해당 파일들이 그대로 응답으로 돌아옵니다.

- `http://localhost:3000/two_cat.png` → `public/two_cat.png` 파일을 보여줍니다.
- `http://localhost:3000/index.html` → `public/index.html` 파일을 보여줍니다.

`express.static()` 미들웨어는 마치 웹 서버(Nginx, Apache 등)의 기능 일부를 Express로 가져온 것처럼 동작하여, 프론트엔드 파일을 함께 서비스할 때 매우 유용합니다.

> **참고 문서**
> [Express 공식 문서 - express.urlencoded()](https://expressjs.com/en/api.html#express.urlencoded)
