## 🎒 미들웨어 간 데이터 공유: `req`와 `res` 객체 활용하기

Express에서 하나의 요청은 여러 미들웨어로 구성된 **미들웨어 체인(Middleware Chain)** 을 순서대로 통과합니다. 이때 아주 중요한 특징이 하나 있습니다. 바로, 체인을 통과하는 동안 **단 하나의 `req` 객체와 `res` 객체가 계속해서 공유된다**는 점입니다.

마치 하나의 **배낭(`req`)** 을 메고 여러 검문소(미들웨어)를 통과하는 것과 같습니다. 각 검문소는 배낭 안의 내용물을 확인할 수 있고, 새로운 물건을 넣을 수도 있습니다.

정말 그런지 코드를 통해 직접 확인해 보겠습니다.

### 하나의 요청, 하나의 `req`와 `res` 객체

아래 코드는 `/hello` 경로에 세 개의 미들웨어(`one`, `two`, `three`)를 연결하고, 각 미들웨어에서 요청으로 들어온 쿼리 스트링(`req.query`)을 출력합니다.

```javascript
// src/app.js
import express from 'express';

const app = express();
const PORT = 3000;

function one(req, res, next) {
  console.log('첫 번째 미들웨어:', req.query);
  return next();
}

function two(req, res, next) {
  console.log('두 번째 미들웨어:', req.query);
  return next();
}

function three(req, res, next) {
  console.log('세 번째 미들웨어:', req.query);
  return res.json({ message: '안녕, 반가워요.' });
}

app.get('/hello', one, two, three);

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

이제 `?name=world` 라는 쿼리 스트링을 담아 요청을 보내보겠습니다.

```http
GET http://localhost:3000/hello?name=world
```

서버 터미널에는 다음과 같은 결과가 출력됩니다.

```bash
첫 번째 미들웨어: [Object: null prototype] { name: 'world' }
두 번째 미dler웨어: [Object: null prototype] { name: 'world' }
세 번째 미들웨어: [Object: null prototype] { name: 'world' }
```

모든 미들웨어가 완전히 동일한 `req.query` 객체를 바라보고 있음을 확인할 수 있습니다.

---

### 💡 `[Object: null prototype]`은 무엇인가요?

이왕 이야기가 나왔으니, `[Object: null prototype]`이 무엇인지 간단히 짚고 넘어가겠습니다.

- **Prototype (프로토타입)**: 자바스크립트의 모든 일반 객체는 `Object.prototype`이라는 '원형' 객체를 상속받습니다. 이 원형 객체 덕분에 우리는 `.toString()`, `.hasOwnProperty()` 같은 내장 메서드를 모든 객체에서 바로 사용할 수 있습니다.

- **Null Prototype Object (프로토타입이 없는 객체)**: `[Object: null prototype]`은 바로 이 '원형' 객체를 상속받지 않은, 아주 깨끗한 상태의 '순수한 데이터 저장소'라고 생각하시면 됩니다.

**Express가 `req.query`에 일반 객체 대신 이 방식을 사용하는 이유**는 **보안과 안정성** 때문입니다. 만약 사용자가 `?toString=hello`와 같은 쿼리를 보내면, 일반 객체에서는 내장 메서드와 충돌할 가능성이 있습니다. 프로토타입이 없는 객체를 사용하면 이러한 잠재적인 문제를 원천적으로 차단할 수 있습니다.

결론적으로, 터미널에 `[Object: null prototype]`이라고 표시되는 것은 Express가 더 안전한 방법으로 쿼리 스트링 데이터를 처리하고 있다는 의미이며, 데이터를 사용하는 데에는 일반 객체와 큰 차이가 없으니 안심하고 사용하셔도 됩니다.

---

### 🌟 실전 예제: 인증 정보 전달하기

이러한 객체 공유 특징은 미들웨어의 역할을 명확히 분리하고, 미들웨어 간에 데이터를 전달해야 할 때 매우 유용하게 사용됩니다.

가장 대표적인 예시는 **인증 미들웨어**입니다. 초기 단계의 미들웨어에서 사용자 인증을 처리한 뒤, 그 결과를 `req` 객체에 담아두면 그 뒤에 오는 모든 미들웨어에서 현재 로그인한 사용자의 정보에 쉽게 접근할 수 있습니다.

```javascript
// src/app.js
import express from 'express';

const app = express();
const PORT = 3000;

// 1. 인증을 처리하는 미들웨어
function authentication(req, res, next) {
  // (실제로는 여기서 데이터베이스 조회 등을 통해 사용자를 확인합니다.)
  // 인증에 성공했다고 가정하고, req 객체의 user 프로퍼티에 사용자 이름을 추가합니다.
  console.log('인증 미들웨어: req.user에 사용자 정보를 추가합니다.');
  req.user = 'ChungAh';
  next(); // 다음 미들웨어로 제어권을 넘깁니다.
}

// 2. 실제 비즈니스 로직을 처리하는 미들웨어
app.get('/me', authentication, (req, res, next) => {
  // 앞선 미들웨어에서 추가한 req.user 값을 여기서 바로 사용할 수 있습니다.
  console.log('메인 핸들러: req.user 값을 확인합니다.');
  console.log(req.user); // 터미널에 'ChungAh' 출력
  res.json({ user: req.user });
});

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

`authentication` 미들웨어가 배낭(`req`)에 `user`라는 이름표를 붙여준 덕분에, 뒤따르는 `/me` 핸들러는 배낭을 열어보기만 하면 누가 요청했는지 바로 알 수 있게 된 것입니다.

---

### `req`와 `res` 중 어디에 저장할까?

`req`와 `res` 모두 객체이므로 커스텀 데이터를 추가할 수 있습니다. 그렇다면 어떤 기준으로 데이터를 저장해야 할까요?

정해진 규칙은 없지만, 일반적으로 다음과 같은 컨벤션을 따르는 것이 좋습니다.

- **`req` 객체**: **요청(Request)** 과 관련된 데이터를 저장합니다. (예: 인증된 사용자 정보, 요청 처리 중 계산된 값 등)
- **`res` 객체**: **응답(Response)** 과 관련된 데이터를 저장합니다. (예: 여러 미들웨어에 걸쳐 만들어지는 응답 데이터 등)

상황에 맞게 `req`와 `res` 객체를 잘 활용하여 미들웨어 간의 데이터 흐름을 명확하게 만드는 것이 중요합니다.
