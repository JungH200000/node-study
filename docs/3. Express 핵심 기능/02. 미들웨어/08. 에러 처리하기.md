## 🚑 Express 에러 처리하기: 서버가 멈추지 않게\!

웹 서버를 운영하다 보면 회원가입 시 비밀번호가 누락되거나, 중복된 이메일로 가입을 시도하는 등 수많은 예외 상황과 마주하게 됩니다. 이런 예외 상황(오류)을 제대로 처리하지 않으면, 서버는 다음에 무엇을 해야 할지 몰라 응답을 보내지 못하고 그대로 멈춰버릴 수도 있습니다.

서버가 멈추는 최악의 상황을 방지하려면, 오류 발생 시 기존 동작을 대신할 별도의 처리 로직을 마련해야 합니다. Express에서는 이 역할을 **오류 처리 미들웨어(Error-Handling Middleware)** 가 담당합니다.

---

### 특별한 미들웨어, 오류 핸들러

Express에서는 오류를 처리하는 것도 미들웨어입니다. 단, 이 미들웨어는 이전에 배웠던 것들과는 조금 다른, 아주 특별한 형태를 가집니다.

> **오류 처리 미들웨어는 항상 4개의 파라미터(`err`, `req`, `res`, `next`)를 가집니다.**

이 미들웨어는 일반적인 요청 흐름에서는 실행되지 않고, 오직 다른 미들웨어에서 오류가 발생했을 때만 특별히 호출됩니다. 오류를 발생시키는 방법은 주로 두 가지입니다.

1.  `throw new Error(...)` 사용 (동기 코드에서)
2.  `next(error)` 호출 (Express에서 권장하는 방식)

---

### 오류를 발생시키는 두 가지 방법

의도적으로 오류를 발생시켜 Express가 기본적으로 어떻게 반응하는지 두 가지 방법으로 각각 살펴보겠습니다.

#### 1\. `throw`로 오류 발생시키기

동기적인 코드 블록 안에서는 `throw` 키워드를 사용하여 오류를 발생시킬 수 있습니다. Express는 이 오류를 감지하여 오류 처리 단계로 넘어갑니다.

```javascript
// src/app.js
import express from 'express';

const app = express();
const PORT = 3000;

function throwError(req, res, next) {
  // throw 키워드로 에러를 던집니다.
  throw new Error('의도적으로 발생시킨 에러입니다! (throw)');
  // throw가 실행되면 함수는 즉시 중단되므로, 아래 코드는 실행되지 않습니다.
}

app.get('/error-throw', throwError);

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

#### 2\. `next(error)`로 오류 발생시키기 (권장)

`next()` 함수에 인자(주로 `Error` 객체)를 전달하는 것은 Express에서 오류를 전달하는 표준 방식입니다. 이 방법은 동기, 비동기 코드 모두에서 일관되게 동작합니다.

```javascript
// src/app.js
// ... (위와 동일) ...

function nextError(req, res, next) {
  // Error 객체를 생성하여 next 함수에 전달합니다.
  const error = new Error('의도적으로 발생시킨 에러입니다! (next)');
  next(error);
}

app.get('/error-next', nextError);

// ... (app.listen은 아래에) ...
```

두 경로(`GET /error-throw`, `GET /error-next`)로 각각 요청을 보내보면, 결과는 동일합니다. Express에 **내장된 기본 오류 핸들러**가 동작하여 아래와 같은 HTML 형식의 응답을 받게 됩니다.

```response
HTTP/1.1 500 Internal Server Error
...
Content-Type: text/html; charset=utf-8
...

<!DOCTYPE html>
<html lang="en">
...
<pre>Error: 의도적으로 발생시킨 에러입니다! ...
...
```

---

### 나만의 JSON 오류 핸들러 만들기

API 서버는 보통 HTML이 아닌 JSON 형식으로 응답해야 합니다. 우리만의 커스텀 오류 핸들러를 만들어 응답 형식을 제어해 보겠습니다.

**⚠️ 중요: 오류 처리 미들웨어는 반드시 다른 모든 `app.use()` 및 라우트 호출 뒤, 즉 코드의 가장 마지막에 위치해야 합니다.** 이는 모든 라우트와 미들웨어에서 발생한 오류를 잡아내는 '최종 안전망' 역할을 하기 때문입니다.

```javascript
// src/app.js
import express from 'express';
// ... (위와 동일한 코드들) ...

app.get('/error-throw', throwError);
app.get('/error-next', nextError);

// ... 다른 모든 라우트들

// 🚨 최하단에 위치한 커스텀 오류 처리 미들웨어
app.use((err, req, res, next) => {
  // err: throw 또는 next(error)로 전달받은 Error 객체

  console.error(err.stack); // 에러 스택을 콘솔에 기록

  // 클라이언트에게는 500 상태 코드와 함께 JSON 형식으로 에러 메시지를 전달
  res.status(500).json({ message: '서버 내부에서 에러가 발생했습니다.' });
});

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

이제 다시 두 경로 중 하나로 요청을 보내면, 우리가 직접 만든 오류 핸들러가 동작하여 깔끔한 JSON 응답을 보내줍니다.

```response
HTTP/1.1 500 Internal Server Error
...
Content-Type: application/json; charset=utf-8
...

{
  "message": "서버 내부에서 에러가 발생했습니다."
}
```
