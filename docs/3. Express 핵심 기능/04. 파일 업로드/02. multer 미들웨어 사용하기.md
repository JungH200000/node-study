## 📤 `multer` 미들웨어로 파일 업로드 구현하기

`application/json` 형식의 요청을 처리하기 위해 `express.json()`을 사용했던 것처럼, 파일이 포함된 `multipart/form-data` 형식의 요청을 처리하기 위해서는 그에 맞는 전문 도구가 필요합니다. Express에서는 바로 **`multer`** 라이브러리가 그 역할을 담당합니다.

`multer`는 `multipart/form-data` 요청 본문을 처리하여, 업로드된 파일은 서버에 저장하고 파일 정보는 `req` 객체에 담아주는 편리한 미들웨어입니다.

---

### `multer` 사용 준비하기

#### 1\. 라이브러리 설치

먼저 `npm`을 통해 `multer`를 설치합니다.

```bash
npm install multer
```

#### 2\. `multer` 설정하기

`multer`를 사용하려면, "업로드된 파일을 어디에 저장할지"를 가장 먼저 알려줘야 합니다.

> **비유로 이해하기: 파일 처리 전문가 채용하기 🧑‍💼**
>
> `multer`는 파일 처리를 전담하는 전문가와 같습니다. 이 전문가를 채용하면서 가장 먼저 해야 할 일은 업무 공간을 지정해 주는 것입니다.

```javascript
// multer 전문가를 import 하고,
import multer from 'multer';

// "앞으로 모든 파일은 'uploads' 폴더에 보관해 주세요" 라고 업무 지시를 내립니다.
const upload = multer({ dest: 'uploads/' });
```

`dest` 옵션은 'destination(목적지)'을 의미하며, 지정된 폴더가 없을 경우 `multer`가 자동으로 생성해 줍니다.

### 라우트에 `multer` 미들웨어 적용하기

이제 설정된 `multer` 미들웨어를 실제 파일 업로드를 처리할 라우트에 적용해 보겠습니다.

```javascript
// src/app.js
import express from 'express';
import multer from 'multer'; // 1. multer import

const app = express();
const PORT = 3000;

// 2. multer 설정: 'uploads/' 폴더에 파일을 저장합니다.
const upload = multer({ dest: 'uploads/' });

// 3. 라우트에 multer 미들웨어 적용
// upload.single('attachment') : 'attachment'라는 이름(name)으로 단일 파일을 받겠다는 의미
app.post('/files', upload.single('attachment'), (req, res) => {
  // 4. 업로드된 파일의 정보는 req.file 객체에 담깁니다.
  console.log(req.file);
  res.json({ message: '파일 업로드 완료!' });
});

app.listen(PORT, () => {
  console.log(`🚀 Server started on port ${PORT}`);
});
```

`upload.single('fieldName')`은 `multer` 전문가에게 "이제 `'fieldName'`이라는 이름표가 붙은 파일을 딱 하나만 받을 준비를 하세요"라고 구체적인 업무 지시를 내리는 것과 같습니다. 이 지시의 결과로 실제 라우트에서 사용할 수 있는 미들웨어 함수가 반환됩니다.

> **더 알아보기:** > `multer`는 하나의 파일(`.single()`), 여러 파일(`.array()`), 여러 필드의 파일들(`.fields()`) 등 다양한 방식의 업로드를 지원합니다. 자세한 내용은 [multer 공식 문서](https://github.com/expressjs/multer/blob/main/doc/README-ko.md)를 참고해 주세요.

---

### 파일 업로드 테스트하기

브라우저의 `<form>` 태그를 사용하면 `multipart/form-data` 요청이 자동으로 생성되지만, 여기서는 API 테스트 도구를 위해 직접 HTTP 요청을 작성해 보겠습니다.

```http
POST http://localhost:3000/files
Content-Type: multipart/form-data; boundary=BoundaryString

--BoundaryString
Content-Disposition: form-data; name="attachment"; filename="hello.txt"
Content-Type: text/plain

Hello, Multer!
--BoundaryString--
```

> **⚠️ 중요:** `Content-Disposition` 헤더의 `name="attachment"` 부분은 `upload.single('attachment')`에 전달한 필드 이름과 **반드시 일치해야 합니다.** 이 이름표가 서로 맞아야 `multer`가 파일을 제대로 인식할 수 있습니다.

요청을 보내고 나면, 프로젝트에 `uploads` 폴더가 생기고 그 안에 파일이 하나 저장된 것을 볼 수 있습니다.

#### 파일 이름이 왜 다른가요?

업로드된 파일의 이름이 `hello.txt`가 아닌, `6fd3ff726...`과 같은 무작위 문자열로 저장된 것을 볼 수 있습니다. 이는 여러 사용자가 같은 이름의 파일을 업로드했을 때 기존 파일이 덮어씌워지는 것을 방지하기 위한 `multer`의 기본 동작입니다. 파일 내용이 변한 것은 아니니 걱정하지 않으셔도 됩니다.

#### `req.file` 객체 살펴보기

동시에 서버 터미널에는 `req.file` 객체의 내용이 출력됩니다. `multer` 전문가가 파일 처리를 마친 뒤 우리에게 전달해 준 '업무 보고서'와 같습니다.

```bash
{
  fieldname: 'attachment',         // 폼 데이터의 필드 이름
  originalname: 'hello.txt',       // 사용자가 업로드한 원본 파일 이름
  encoding: '7bit',                // 파일 인코딩 타입
  mimetype: 'text/plain',          // 파일의 MIME 타입 (ex: image/jpeg)
  destination: 'uploads/',         // 파일이 저장된 폴더
  filename: '6fd3ff726...',        // 서버에 저장된 실제 파일 이름
  path: 'uploads\\6fd3ff726...',    // 서버에 저장된 전체 경로
  size: 14                         // 파일 크기 (bytes)
}
```

이 `req.file` 객체의 정보를 활용하여, 데이터베이스에 파일 정보를 저장하는 등의 후속 작업을 처리할 수 있습니다.
