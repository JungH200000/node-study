## 🔗 관계를 따라서 데이터 가져오기: `include`와 `select`

지금까지는 `User`를 조회하면 `User` 정보만, `Product`를 조회하면 `Product` 정보만 가져왔습니다. 하지만 실제 애플리케이션에서는 '특정 유저 정보와 그 유저의 설정 정보를 한 번에' 가져오거나, '특정 유저가 찜한 상품 목록'을 가져오는 것처럼 관계를 넘나들며 데이터를 조회해야 할 때가 많습니다.

Prisma의 강력한 **`include`** 와 **`select`** 옵션을 사용하면 이런 작업을 아주 간단하게 처리할 수 있습니다.

---

### 1. 관련 데이터 함께 조회하기: `include`

**`include`** 옵션을 사용하면, 특정 데이터를 조회할 때 그와 **관계된 다른 모델의 데이터를 함께** 가져올 수 있습니다.

예를 들어, `GET /users`와 `GET /users/:id` API가 유저 정보뿐만 아니라, 그 유저의 `UserPreference` 정보까지 함께 반환하도록 수정해 보겠습니다.

#### ✨ 코드 수정

각 라우트의 `findMany()`와 `findUniqueOrThrow()` 메소드 안에 `include` 옵션을 추가하고, 함께 가져오고 싶은 관계 필드(`userPreference`)를 `true`로 설정합니다.

```javascript
/* ========== users ========== */
app.get(
  '/users',
  asyncHandler(async (req, res) => {
    // ... (쿼리 파라미터 로직은 동일)
    const users = await prisma.user.findMany({
      skip: parseInt(offset),
      take: parseInt(limit),
      orderBy,
      include: {
        userPreference: true, // userPreference 관계 데이터를 포함
      },
    });
    res.send(users);
  })
);

app.get(
  '/users/:id',
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    const user = await prisma.user.findUniqueOrThrow({
      where: { id },
      include: {
        userPreference: true, // userPreference 관계 데이터를 포함
      },
    });
    res.send(user);
  })
);
```

#### ✅ 결과 확인

이제 `GET http://localhost:3000/users`를 요청하면, `userPreference` 객체가 각 유저 정보 안에 중첩(nesting)되어 함께 반환됩니다.

```json
[
  {
    "id": "73cb9639-d8b7-4f11-9a62-53f4187f3f11",
    "email": "jungminsoo@example.com",
    // ...
    "userPreference": {
      "id": "0b5a06cd-5d25-4b3c-bc52-b06ee7b17662",
      "receiveEmail": true
      // ...
    }
  }
  // ...
]
```

---

### 2. 🎯 원하는 정보만 쏙쏙 골라 담기: `select` 활용

`include`는 관계된 데이터의 '모든' 필드를 가져옵니다. 만약 관계된 데이터나 원본 데이터에서 **특정 필드만** 골라서 가져오고 싶다면, **`select`** 옵션을 사용할 수 있습니다.

#### 관계된 객체의 특정 필드만 조회하기

`userPreference`에서 `receiveEmail` 필드만 필요하다면, `include` 안에서 `select`를 사용합니다.

```javascript
const users = await prisma.user.findMany({
  // ... (skip, take, orderBy)
  include: {
    userPreference: {
      select: {
        receiveEmail: true, // userPreference에서 이 필드만 선택
      },
    },
  },
});
```

**[응답 예시]**
이제 `userPreference` 객체 안에는 `receiveEmail` 필드만 포함됩니다.

```json
// ...
"userPreference": {
  "receiveEmail": true
}
// ...
```

#### 원본 객체의 특정 필드만 조회하기

`select`는 `include` 밖의 최상위 레벨에서도 사용할 수 있습니다. 이 경우, **응답에 포함될 필드를 직접 모두 명시**해야 합니다.

```javascript
const users = await prisma.user.findMany({
  // ...
  select: {
    email: true, // User 모델에서 email 필드만 선택
    firstName: true, // User 모델에서 firstName 필드만 선택
  },
});
```

> **💡 `include`와 `select`는 함께 사용할 수 없어요\!**
>
> Prisma 쿼리의 최상위 레벨에서는 `include`(모든 필드 + 지정한 관계)와 `select`(지정한 필드만)를 동시에 사용할 수 없습니다. '전부 포함할지' 또는 '일부만 선택할지' 둘 중 하나의 방식만 사용해야 합니다.

`select`를 사용하면 API 응답의 크기를 줄여 성능을 최적화할 수 있습니다. `include` 내에서 `select`를 사용하는 것은 불필요한 데이터를 제외하고 원하는 모양으로 응답을 만들기 위한 Prisma의 강력하고 유용한 기능입니다.

---

### 🛍️ 실전 예제: 특정 유저가 찜한 상품 목록 API 만들기

`User`와 `Product`의 다대다(N:N) 관계를 활용하여, 특정 유저가 찜한 상품 목록을 반환하는 새로운 API 엔드포인트를 만들어 보겠습니다.

**엔드포인트**: `GET /users/:id/saved-products`

```javascript
// /app.js

app.get(
  '/users/:id/saved-products',
  asyncHandler(async (req, res) => {
    const { id } = req.params;

    // 1. id로 유저를 찾으면서, savedProducts 관계 데이터를 함께 가져옵니다.
    const { savedProducts } = await prisma.user.findUniqueOrThrow({
      where: { id },
      include: {
        savedProducts: true, // 찜한 상품 목록을 포함
      },
    });

    // 2. 결과에서 savedProducts 배열만 바로 응답으로 보냅니다.
    res.send(savedProducts);
  })
);
```

구조 분해 할당(`const { savedProducts } = ...`)을 사용하면, 조회 결과에서 `savedProducts` 배열만 깔끔하게 추출하여 바로 응답으로 보낼 수 있습니다.

**[API 테스트]**
`GET http://localhost:3000/users/73cb9639-d8b7-4f11-9a62-53f4187f3f11/saved-products`

**[응답 예시]**
해당 유저가 찜한 상품들의 정보가 배열 형태로 깔끔하게 반환됩니다.

```json
[
  {
    "id": "be13a617-8f0e-4806-82f7-149a6e12f1a7",
    "name": "삼성 55인치 QLED 4K 스마트 TV"
    // ...
  },
  {
    "id": "d3f74179-2cb5-4e51-8f3a-57f65c1d4e6e",
    "name": "루이스 카스텔리 미니 프라이팬"
    // ...
  }
]
```

이처럼 `include`를 활용하면 복잡한 데이터베이스 조인(JOIN) 작업을 단 몇 줄의 코드로 우아하게 처리할 수 있습니다.
