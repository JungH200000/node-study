## ✨ 한 번의 요청으로 함께\! 관련된 객체 생성 및 수정하기

지금까지는 `User`를 생성한 뒤, 별도의 요청으로 `UserPreference`를 만들고 연결해야 했습니다. 하지만 Prisma의 **중첩 쓰기(Nested Writes)** 기능을 사용하면, **단 한 번의 API 요청**으로 `User`와 `UserPreference`를 **동시에 생성하거나 수정**할 수 있습니다.

이는 클라이언트의 편의성을 크게 높여주는 매우 강력한 기능입니다.

---

### 1. `User`와 `UserPreference` 함께 생성하기 (Nested Create)

#### 1단계: API 요청 형식 변경

먼저, 클라이언트가 `User` 정보와 `UserPreference` 정보를 한 번에 보낼 수 있도록 API 요청 형식을 설계합니다.

```http
# /http/users.http

POST http://localhost:3000/users
Content-Type: application/json

{
  "email": "hyun@example.com",
  "firstName": "사",
  "lastName": "현",
  "address": "부산광역시 북구",
  "userPreference": {
    "receiveEmail": false
  }
}
```

`req.body` 안에 `userPreference` 객체가 중첩되어 들어오는 형태입니다.

#### 2단계: 유효성 검사 Struct 업데이트

새로운 요청 형식에 맞게 `structs.js`의 `CreateUser`를 수정하여, `userPreference` 객체에 대한 유효성 검사 규칙을 추가합니다.

```javascript
// /structs.js
export const CreateUser = s.object({
  email: s.define('Email', isEmail),
  firstName: s.size(s.string(), 1, 30),
  lastName: s.size(s.string(), 1, 30),
  address: s.string(),
  userPreference: s.object({
    receiveEmail: s.boolean(),
  }),
});
```

#### 3단계: `POST /users` 라우트 구현하기

라우트 핸들러에서 `req.body`로부터 `userPreference` 데이터와 나머지 `userFields`를 분리한 뒤, Prisma의 `create` 옵션을 사용하여 두 데이터를 동시에 생성합니다.

```javascript
// /app.js
app.post(
  '/users',
  asyncHandler(async (req, res) => {
    assert(req.body, CreateUser);

    // 1. req.body에서 userPreference와 나머지 userFields를 분리합니다.
    const { userPreference, ...userFields } = req.body;

    const user = await prisma.user.create({
      data: {
        // 2. userFields는 그대로 전달하고,
        ...userFields,
        // 3. userPreference 관계 필드 안에 create 옵션을 사용합니다.
        userPreference: {
          create: userPreference,
        },
      },
      // 4. 생성된 userPreference 정보도 함께 반환하도록 include 옵션을 추가합니다.
      include: {
        userPreference: true,
      },
    });
    res.status(201).send(user);
  })
);
```

> **💡 나머지 연산자(`...`)를 이용한 객체 분리**
>
> `const { userPreference, ...userFields } = req.body;`는 구조 분해 할당과 나머지 연산자를 함께 사용한 매우 유용한 패턴입니다. `req.body`에서 `userPreference` 속성을 추출하여 `userPreference` 변수에 담고, **그것을 제외한 나머지 모든 속성**들을 `userFields`라는 새로운 객체에 모아줍니다.

#### ✅ 결과 확인

요청을 보내면 `User`와 `UserPreference`가 함께 생성되고, 서로의 ID로 연결된 완전한 데이터가 응답으로 돌아옵니다.

```json
{
  "id": "b54f6175-d7b9-43c3-b39a-4e7dddc0ee14",
  "email": "hyun@example.com",
  // ...
  "userPreference": {
    "id": "04b17225-da15-43f1-9346-3f451fc67fed",
    "receiveEmail": false,
    "userId": "b54f6175-d7b9-43c3-b39a-4e7dddc0ee14"
  }
}
```

---

### 2. `User`와 `UserPreference` 함께 수정하기 (Nested Update)

데이터 수정도 생성과 거의 동일한 방식으로, 관계 필드 안에서 `create` 대신 `update` 옵션을 사용하면 됩니다.

#### `PATCH /users/:id` 라우트 구현하기

```javascript
// /app.js
app.patch(
  '/users/:id',
  asyncHandler(async (req, res) => {
    assert(req.body, PatchUser);
    const { userPreference, ...userFields } = req.body;
    const { id } = req.params;

    const user = await prisma.user.update({
      where: { id },
      data: {
        ...userFields, // User 정보 업데이트
        userPreference: {
          update: userPreference, // 관련된 UserPreference 정보 업데이트
        },
      },
      include: {
        userPreference: true,
      },
    });
    res.send(user);
  })
);
```

#### ✅ 테스트 및 결과 확인

아래와 같이 `email`과 `userPreference.receiveEmail`을 동시에 수정하는 요청을 보내면, 두 데이터가 모두 업데이트되어 응답됩니다.

```http
PATCH http://localhost:3000/users/b54f6175-d7b9-43c3-b39a-4e7dddc0ee14
Content-Type: application/json

{
  "email": "hyunSass@example.com",
  "userPreference": {
    "receiveEmail": true
  }
}
```

Prisma의 중첩 쓰기 기능을 활용하면, 여러 번의 API 호출을 한 번으로 줄여 더 효율적이고 편리한 API를 만들 수 있습니다.
