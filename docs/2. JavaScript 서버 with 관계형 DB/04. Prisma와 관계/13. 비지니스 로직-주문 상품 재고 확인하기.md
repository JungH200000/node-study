## ⚙️ 서비스의 규칙 만들기: 비즈니스 로직 구현하기 (재고 확인)

지금까지 우리는 클라이언트가 보내준 데이터를 그대로 데이터베이스에 저장했습니다. 하지만 실제 서비스에서는 데이터를 저장하기 전에 **현실 세계의 규칙이나 제약 조건**을 먼저 확인해야 합니다. 예를 들어, "상품의 재고가 충분한 경우에만 주문을 생성할 수 있다" 와 같은 규칙이죠.

이렇게 서비스의 핵심 규칙을 코드로 구현하는 것을 **비즈니스 로직(Business Logic)** 이라고 부릅니다. 비즈니스 로직을 정확하게 구현해야 비로소 견고한 백엔드 서버를 만들 수 있습니다.

이번 가이드에서는 `POST /orders` API에 **'주문 상품 재고 확인'** 비즈니스 로직을 추가해 보겠습니다.

---

### 1단계: 재고 확인에 필요한 상품 정보 가져오기

주문을 생성하기 전에, 주문하려는 모든 상품들의 현재 재고를 데이터베이스에서 먼저 가져와야 합니다.

`app.js`의 `POST /orders` 라우트 핸들러를 다음과 같이 수정합니다.

```javascript
// /app.js
app.post(
  '/orders',
  asyncHandler(async (req, res) => {
    assert(req.body, CreateOrder);
    const { userId, orderItems } = req.body;

    // 1. 주문하려는 모든 상품의 ID 목록을 추출합니다.
    const productIds = orderItems.map((item) => item.productId);

    // 2. ID 목록을 사용해, DB에서 해당하는 상품 정보를 모두 가져옵니다.
    const products = await prisma.product.findMany({
      where: {
        id: {
          in: productIds, // productIds 배열에 포함된 id를 가진 상품만 조회
        },
      },
    });

    // ... (재고 확인 로직 추가 예정)
  })
);
```

---

### 2단계: 모든 상품의 재고가 충분한지 확인하기

이제 데이터베이스에서 가져온 실제 재고(`products` 배열)와 사용자가 주문하려는 수량(`orderItems` 배열)을 비교하여, 모든 상품의 재고가 충분한지 확인해야 합니다.

```javascript
// /app.js
// ... (products를 가져온 코드 아래에)

// 3. 각 상품의 재고가 주문 수량보다 충분한지 확인합니다.
const isSufficientStock = products.every((product) => {
  const orderItem = orderItems.find((item) => item.productId === product.id);
  return product.stock >= orderItem.quantity;
});

// 4. 재고가 하나라도 부족한 경우, 에러를 발생시켜 주문 생성을 막습니다.
if (!isSufficientStock) {
  throw new Error('Insufficient Stock');
}

// ... (주문 생성 로직)
```

#### **JavaScript 핵심 개념 자세히 보기**

##### `Array.prototype.every()`

`every` 메소드는 배열의 **모든** 요소가 주어진 조건을 통과하는지 검사하는 '깐깐한 심사관'과 같습니다.

- **동작 방식**: 배열의 각 요소(`product`)를 순회하며 콜백 함수를 실행합니다.
- **결과**: 콜백 함수가 **단 한 번이라도 `false`를 반환하면 즉시 중단하고 `false`를 최종 반환**합니다. 모든 요소에 대해 `true`를 반환해야만 최종적으로 `true`를 반환합니다.
- **우리의 코드**: 주문하려는 상품 중 단 하나라도 재고(`product.stock`)가 주문 수량(`orderItem.quantity`)보다 적으면, `isSufficientStock` 변수는 `false`가 됩니다.

##### `if (!isSufficientStock)`

`!`는 논리 NOT 연산자로, boolean 값을 반대로 뒤집습니다.

- `isSufficientStock`이 `true`이면 (재고 충분), `!isSufficientStock`은 `false`가 되어 `if`문이 실행되지 않습니다.
- `isSufficientStock`이 `false`이면 (재고 부족), `!isSufficientStock`은 `true`가 되어 `if`문이 실행되고, `throw new Error()`를 통해 에러를 발생시킵니다.

이렇게 발생한 에러는 `asyncHandler`가 안전하게 잡아내어, 서버가 멈추는 대신 `500 Internal Server Error`와 함께 "Insufficient Stock" 메시지를 클라이언트에 응답하게 됩니다.

---

### ✅ 최종 코드 및 테스트

지금까지의 재고 확인 로직을 모두 포함한 `POST /orders` 라우트의 최종 코드는 다음과 같습니다.

```javascript
// /app.js

app.post(
  '/orders',
  asyncHandler(async (req, res) => {
    assert(req.body, CreateOrder);
    const { userId, orderItems } = req.body;

    const productIds = orderItems.map((item) => item.productId);
    const products = await prisma.product.findMany({
      where: { id: { in: productIds } },
    });

    // 모든 상품의 재고가 충분한지 확인
    const isSufficientStock = products.every((product) => {
      const orderItem = orderItems.find((item) => item.productId === product.id);
      return product.stock >= orderItem.quantity;
    });

    if (!isSufficientStock) {
      throw new Error('Insufficient Stock');
    }

    // 재고가 충분하다면 주문 생성 로직 실행
    const order = await prisma.order.create({
      data: {
        userId: userId,
        orderItems: {
          create: orderItems,
        },
      },
      include: {
        orderItems: true,
      },
    });
    res.status(201).send(order);
  })
);
```

#### **API 테스트 해보기**

`id`가 `1e112c02...`인 상품의 재고가 `5`개라고 가정해 봅시다.

- **성공 케이스**: `quantity`를 `1`로 하여 주문 요청을 보내면, 재고가 충분하므로 `201 Created`와 함께 주문 정보가 성공적으로 반환됩니다.
- **실패 케이스**: `quantity`를 `10`으로 변경하여 다시 요청을 보내면, 재고가 부족하므로 `500 Internal Server Error`와 함께 `{"message": "Insufficient Stock"}` 이라는 에러 메시지가 반환됩니다.

이제 여러분의 주문 API는 실제 서비스처럼 재고까지 확인하는 똑똑한 비즈니스 로직을 갖추게 되었습니다\!
