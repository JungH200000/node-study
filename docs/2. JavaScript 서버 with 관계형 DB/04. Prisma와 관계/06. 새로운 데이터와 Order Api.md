## 🚀 새로운 데이터와 Order API

이제 우리의 e-커머스 서버에 필요한 모든 모델(`User`, `Product`, `Order` 등)이 준비되었습니다. 이번 가이드에서는 더 풍부해진 초기 데이터를 데이터베이스에 시딩(seeding)하고, `Order`에 대한 CRUD API를 구현해 보겠습니다.

### 1. 새로운 시드(Seed) 데이터 살펴보기

새로 제공된 `prisma/mock.js` 파일에는 5개 모델(`USERS`, `PRODUCTS`, `USER_PREFERENCES`, `ORDERS`, `ORDER_ITEMS`)에 대한 초기 데이터가 모두 포함되어 있습니다.

특히, `User`가 `Product`를 찜하거나(`savedProducts`), `Order`가 특정 `User`에게 속하는 등, 데이터 간의 **관계**까지 mock 데이터에 정의되어 있는 것을 볼 수 있습니다.

```javascript
// /prisma/mock.js 일부

export const USERS = [
  // ...
  {
    id: '6c3a18b0-11c5-4d97-9019-9ebe3c4d1317',
    // ...
    // User와 Product의 다대다 관계를 connect로 표현
    savedProducts: {
      connect: [
        { id: 'f8013040-b076-4dc4-8677-11be9a17162f' },
        // ...
      ],
    },
  },
];

export const ORDERS = [
  {
    id: '9fde1702-08d7-407c-8e6e-65e24f6a8237',
    // ...
    // Order와 User의 일대다 관계를 외래 키로 표현
    userId: 'b8f11e76-0a9e-4b3f-bccf-8d9b4fbf331e',
  },
];
```

---

### 2. 시드 스크립트 업데이트하기

새로운 mock 데이터를 모두 데이터베이스에 삽입할 수 있도록 `prisma/seed.js` 파일을 업데이트합니다.

```javascript
// /prisma/seed.js
import { PrismaClient } from '../generated/prisma/index.js';
import { USERS, PRODUCTS, USER_PREFERENCES, ORDERS, ORDER_ITEMS } from './mock.js';

const prisma = new PrismaClient();

async function main() {
  // 1. 기존 데이터 삭제 (관계의 종속성을 고려하여 자식 테이블부터 삭제)
  await prisma.orderItem.deleteMany();
  await prisma.order.deleteMany();
  await prisma.userPreference.deleteMany();
  await prisma.user.deleteMany();
  await prisma.product.deleteMany();
  console.log('🗑️ All existing data deleted.');

  // 2. 참조되는 데이터(부모) 먼저 생성
  await prisma.product.createMany({
    data: PRODUCTS,
    skipDuplicates: true,
  });
  console.log('📥 Products seeded successfully.');

  // 3. 관계가 포함된 데이터 생성 (Promise.all + create)
  await Promise.all(
    USERS.map(async (user) => {
      await prisma.user.create({ data: user });
    })
  );
  console.log('📥 Users seeded successfully.');

  // 4. 나머지 데이터 순서대로 생성
  await prisma.userPreference.createMany({
    data: USER_PREFERENCES,
    skipDuplicates: true,
  });
  await prisma.order.createMany({
    data: ORDERS,
    skipDuplicates: true,
  });
  await prisma.orderItem.createMany({
    data: ORDER_ITEMS,
    skipDuplicates: true,
  });
  console.log('✅ All data seeded successfully!');
}

main()
  .then(async () => await prisma.$disconnect())
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });
```

> **🏛️ 잠깐\! 삭제와 생성 순서가 왜 중요한가요?**
>
> 데이터베이스에서 관계는 **외래 키 제약 조건(Foreign Key Constraint)** 으로 유지됩니다. 이는 "자식은 부모 없이 존재할 수 없다"는 규칙과 같습니다.
>
> - **삭제 시**: 자식(`OrderItem`)이 부모(`Order`)를 참조하는 한 부모를 먼저 삭제할 수 없습니다. 따라서 **자식부터 부모 순서**로 삭제해야 합니다.
> - **생성 시**: 자식(`Order`)이 참조할 부모(`User`)가 먼저 존재해야 합니다. 따라서 **부모부터 자식 순서**로 생성해야 합니다.

> **🤝 `Promise.all`은 왜 사용했나요?**
>
> `Promise`는 비동기 작업(예: DB 쿼리)의 최종 성공 또는 실패를 나타내는 '약속 증서'입니다. `USERS.map(...)`은 여러 개의 `prisma.user.create()`라는 비동기 작업을 배열 형태로 반환합니다.
>
> **`Promise.all()`** 은 이 '약속 증서' 배열을 인자로 받아, **모든 약속이 성공적으로 끝날 때까지 기다려주는** 역할을 합니다. 이를 통해 여러 유저 생성 작업을 동시에 효율적으로 처리할 수 있습니다.

---

### 3. 주문(Order) 데이터 유효성 검사 Struct 만들기

`structs.js` 파일에 `Order` 생성 및 수정을 위한 유효성 검사 규칙을 추가합니다.

```javascript
// /structs.js
import * as s from 'superstruct';
import isEmail from 'is-email';
import isUuid from 'is-uuid';

// ... (User, Product 관련 struct) ...

/* ========== Order ========== */
const STATUSES = ['PENDING', 'COMPLETE'];

// 'Uuid'라는 커스텀 타입을 정의합니다.
const Uuid = s.define('Uuid', (value) => isUuid.v4(value));

export const CreateOrder = s.object({
  userId: Uuid,
});

export const PatchOrder = s.object({
  status: s.enums(STATUSES),
});
```

> **✨ `s.define`으로 나만의 타입 만들기**
>
> `s.define()`은 `superstruct`의 강력한 기능으로, 나만의 유효성 검사 규칙을 가진 새로운 타입을 만들 수 있게 해줍니다.
>
> - **첫 번째 인자 (`'Uuid'`)**: 오류 메시지에 표시될 새로운 타입의 이름입니다.
> - **두 번째 인자 (`(value) => ...`)**: 실제 검사를 수행하는 **검증 함수(validator function)** 입니다. 이 함수는 검사할 값을 받아, 유효하면 `true`, 아니면 `false`를 반환해야 합니다.
>
> 여기서는 `is-uuid` 라이브러리를 사용해 값이 v4 형식의 UUID가 맞는지 확인하는 `Uuid` 타입을 새로 정의했습니다.

---

### 4. 주문(Order) CRUD API 라우트 구현하기

이제 `app.js`에 `Order` 모델에 대한 CRUD API 라우트들을 추가하고 `asyncHandler`로 감싸줍니다.

```javascript
// /app.js
// ... (import) ...
import { CreateUser, PatchUser, CreateProduct, PatchProduct, CreateOrder, PatchOrder } from './structs.js';

// ... (asyncHandler 함수) ...

/* ========== orders ========== */
app.get(
  '/orders',
  asyncHandler(async (req, res) => {
    const orders = await prisma.order.findMany();
    res.send(orders);
  })
);

app.get(
  '/orders/:id',
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    const order = await prisma.order.findUniqueOrThrow({ where: { id } });
    res.send(order);
  })
);

app.post(
  '/orders',
  asyncHandler(async (req, res) => {
    assert(req.body, CreateOrder);
    const order = await prisma.order.create({ data: req.body });
    res.status(201).send(order);
  })
);

app.patch(
  '/orders/:id',
  asyncHandler(async (req, res) => {
    assert(req.body, PatchOrder);
    const { id } = req.params;
    const order = await prisma.order.update({
      where: { id },
      data: req.body,
    });
    res.send(order);
  })
);

app.delete(
  '/orders/:id',
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    await prisma.order.delete({ where: { id } });
    res.sendStatus(204);
  })
);

// ... (서버 시작 코드)
```

---

### 5. 최종 테스트

1.  `npx prisma db seed` 명령어로 데이터베이스를 새로운 mock 데이터로 초기화합니다.
2.  `npm run dev`로 서버를 실행합니다.
3.  `http/orders.http` 파일을 만들어 다양한 `Order` API 요청을 보내고, 모든 기능이 정상적으로 동작하는지 확인합니다.

이제 모든 모델에 대한 CRUD API와 유효성 검사, 에러 처리까지 갖춘 완전한 e-커머스 백엔드 서버가 완성되었습니다\! 🎉
