## 🎟️ 쿼리를 안전하게 실행하기: 트랜잭션(Transaction)

이전 가이드에서 재고 확인 및 감소 로직을 추가했지만, 아직 한 가지 아쉬운 점이 남아있습니다. 현재 코드는 '주문 생성'과 '재고 감소'라는 두 가지 중요한 작업을 따로따로 실행합니다.

```javascript
// 1. 주문을 먼저 생성하고,
const order = await prisma.order.create({ ... });

// 2. 그 다음에 재고를 감소시킨다.
const queries = productIds.map(/* ... */);
await Promise.all(queries);

res.status(201).send(order);
```

만약 주문 생성은 성공했는데, 그 직후 서버가 다운되거나 예기치 못한 오류가 발생하여 재고 감소 로직이 실패하면 어떻게 될까요? **주문은 생성되었지만 재고는 그대로인, 데이터가 일치하지 않는 심각한 문제**가 발생합니다.

실제 서비스에서는 이런 상황이 절대 발생해서는 안 됩니다.

### 문제 상황 재현하기

이 문제를 직접 눈으로 확인해 봅시다. 재고 감소 로직에서, `where: { id: productId }`를 `where: { id: 123 }`처럼 일부러 잘못된 값으로 수정하여 오류를 유발해 보겠습니다.

1.  `GET /orders`로 현재 주문 개수를 확인합니다. (예: 10개)
2.  `POST /orders`로 새로운 주문을 요청합니다.
    - `prisma.order.create()`는 성공적으로 실행됩니다.
    - 하지만 재고 감소 로직에서 `id` 타입이 맞지 않아 오류가 발생하고, `400 Bad Request` 응답이 돌아옵니다.
3.  다시 `GET /orders`로 주문 개수를 확인합니다.
    - 주문이 **11개**로 늘어난 것을 볼 수 있습니다. 하지만 상품들의 재고는 전혀 감소하지 않았습니다.

데이터의 일관성이 깨져버린 것입니다.

---

### 해결의 열쇠: 트랜잭션(Transaction)

이렇게 여러 개의 작업을 **'하나의 묶음'** 처럼 다뤄야 할 때 사용하는 것이 바로 **트랜잭션(Transaction)** 입니다.

> **트랜잭션이란?** 🏦
>
> 은행에서 계좌 이체를 하는 과정을 생각해보세요. "내 통장에서 5만원 빼기"와 "친구 통장에 5만원 더하기"라는 두 작업은 반드시 함께 성공해야 합니다. 하나라도 실패하면, 두 작업 모두 없었던 일(취소)로 되돌려야 하죠.
>
> 트랜잭션은 이처럼 **묶음 안의 모든 작업이 전부 성공하거나, 하나라도 실패하면 전부 실패(롤백)** 하는 것을 보장하는 데이터베이스 기능입니다. 'All or Nothing', 즉 '전부 아니면 전무' 원칙이죠.

Prisma에서는 `prisma.$transaction()` 메소드로 아주 간단하게 트랜잭션을 사용할 수 있습니다.

---

### 최종 코드: `prisma.$transaction()` 적용하기

`$transaction()`은 `Promise.all`과 아주 비슷하게, 실행할 쿼리(프로미스)들을 배열 형태로 전달받습니다. Prisma는 이 배열 안의 모든 쿼리를 하나의 트랜잭션으로 묶어서 실행하고, 하나라도 실패하면 모든 작업을 원래대로 되돌려 놓습니다.

```javascript
// /app.js

app.post(
  '/orders',
  asyncHandler(async (req, res) => {
    // ... (재고 확인 로직까지는 동일) ...
    if (!isSufficientStock) {
      throw new Error('Insufficient Stock');
    }

    // 1. 재고를 감소시키는 update 쿼리들을 배열로 미리 준비합니다.
    const updateQueries = productIds.map((productId) =>
      prisma.product.update({
        where: { id: productId },
        data: {
          stock: {
            decrement: getQuantity(productId),
          },
        },
      })
    );

    // 2. 주문을 생성하는 create 쿼리를 준비합니다.
    const createOrderQuery = prisma.order.create({
      data: {
        userId,
        orderItems: {
          create: orderItems,
        },
      },
      include: {
        orderItems: true,
      },
    });

    // 3. $transaction을 사용해 두 종류의 쿼리를 하나의 트랜잭션으로 묶어 실행합니다.
    const results = await prisma.$transaction([...updateQueries, createOrderQuery]);

    // 4. 트랜잭션 결과에서 주문 생성 결과(마지막 결과)를 가져와 응답합니다.
    const order = results[results.length - 1];
    res.status(201).send(order);
  })
);
```

- `$transaction`은 전달된 쿼리 배열의 각 결과값을 담은 배열을 반환합니다. 우리는 마지막 쿼리인 `createOrderQuery`의 결과만 필요하므로, 결과 배열의 마지막 요소를 가져와 사용합니다.

---

### ✅ 트랜잭션 테스트하기

이제 다시 재고 감소 로직에 일부러 오류를 유발하고 테스트해 봅시다.

1.  `GET /orders`로 현재 주문 개수를 확인합니다. (예: 11개)
2.  `POST /orders`로 새로운 주문을 요청합니다.
    - `update` 쿼리에서 오류가 발생하므로, 트랜잭션 전체가 실패(롤백)됩니다.
    - `asyncHandler`가 오류를 잡아 `500 Internal Server Error`를 응답합니다.
3.  서버를 재시작한 후, 다시 `GET /orders`로 주문 개수를 확인합니다.
    - 이전과 달리, 주문이 추가되지 않고 **여전히 11개**인 것을 확인할 수 있습니다.

`$transaction` 덕분에 재고 감소가 실패하자, 이미 성공했던 것처럼 보였던 주문 생성 작업까지 모두 취소된 것입니다.

이제 id를 올바르게 수정하고 시딩(`npx prisma db seed`)으로 데이터를 초기화한 뒤 다시 주문을 생성하면, 주문 생성과 재고 감소가 모두 안전하게 처리되는 것을 확인할 수 있습니다.

---

### 📖 핵심 요약

이번 가이드를 통해 우리는 **비즈니스 로직**을 API에 구현하고, **트랜잭션**을 사용하여 여러 데이터베이스 작업을 안전하게 처리하는 방법을 배웠습니다. 이 두 가지는 실제 서비스를 개발할 때 데이터의 **일관성과 안정성**을 보장하는 매우 중요한 개념입니다.
