## 🛡️ API 안정성 높이기: 에러 핸들링 적용하기

`superstruct`로 유효성 검사를 추가했지만, 검사에 실패하면 `StructError`가 발생하며 서버가 멈추는 문제가 있었습니다. 이처럼 **비동기 코드에서 발생하는 오류를 처리**하여, 사용자의 잘못된 요청이나 예기치 않은 문제에도 서버가 안정적으로 동작하도록 만드는 것은 매우 중요합니다.

### 1. 비동기 에러, 왜 문제일까요?

기본적으로 **Express 4 버전까지는** `async`로 선언된 라우트 핸들러 내부에서 발생하는 비동기 오류를 자동으로 처리하지 못합니다. 그래서 처리되지 않은 오류(Unhandled Promise Rejection)가 발생하면 프로세스 전체가 멈춰버리는 것입니다.

이 문제를 해결하는 가장 좋은 방법은, 이전 프로젝트에서 사용했던 것처럼 **모든 비동기 핸들러를 `try...catch`로 감싸주는 헬퍼 함수**를 사용하는 것입니다.

> **💡 Express 5부터는?**
> 최신 버전인 Express 5부터는 `async` 핸들러에서 발생하는 오류를 자동으로 감지하여 에러 처리 미들웨어로 넘겨줍니다. 하지만 Express 4 기반의 프로젝트가 여전히 많고, 에러 처리 원리를 이해하는 것이 중요하므로 이 방식을 배워두는 것은 매우 유용합니다.

### 2. Prisma 환경에 맞는 `asyncHandler` 만들기

이전 Mongoose 프로젝트에서 사용했던 `asyncHandler`를 가져오되, Prisma와 `superstruct` 환경에 맞게 오류 처리 조건을 수정해야 합니다.

| 발생 상황            | Mongoose 오류                | Prisma / Superstruct 오류                                           | 상태 코드 |
| :------------------- | :--------------------------- | :------------------------------------------------------------------ | :-------- |
| **유효성 검사 실패** | `ValidationError`            | `StructError` (superstruct), `PrismaClientValidationError` (Prisma) | 400       |
| **데이터 찾기 실패** | `CastError` (잘못된 ID 형식) | `PrismaClientKnownRequestError` (code: `P2025`)                     | 404       |
| **서버 내부 오류**   | (기타 오류)                  | (기타 오류)                                                         | 500       |

- `e.name === 'StructError'`
  - Superstruct 객체와 형식이 다를 경우 발생
- `e instanceof Prisma.PrismaClientValidationError`
  - 데이터를 저장할 때 모델에 정의된 형식과 다른 경우 발생 (Superstruct로 철저히 검사하면 이 상황은 잘 발생하지 않지만 안전성을 위해 둘 다 검사)
- `e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2025'`
  - 객체를 찾을 수 없을 경우 발생

이 규칙에 맞춰 `asyncHandler` 함수를 완성해 보겠습니다.

```javascript
// /app.js
import { PrismaClient, Prisma } from './generated/prisma/index.js';
// ...

function asyncHandler(handler) {
  return async function (req, res) {
    try {
      await handler(req, res);
    } catch (e) {
      if (e.name === 'StructError' || e instanceof Prisma.PrismaClientValidationError) {
        // Superstruct 또는 Prisma 유효성 검사 오류일 경우
        res.status(400).send({ message: e.message });
      } else if (e instanceof Prisma.PrismaClientKnownRequestError && e.code === 'P2025') {
        // Prisma에서 '찾을 수 없음' 오류(P2025)일 경우
        res.status(404).send({ message: 'Cannot find given id.' });
      } else {
        // 그 외 모든 서버 내부 오류
        res.status(500).send({ message: e.message });
      }
    }
  };
}
```

> **📚 참고 자료** > `P2025`와 같은 Prisma의 다양한 오류 코드는 공식 문서에서 확인할 수 있습니다.
> [Prisma Error Reference](https://www.prisma.io/docs/orm/reference/error-reference)

---

### 3. 'Not Found' 오류 통일하기: `findUniqueOrThrow`

한 가지 문제가 더 있습니다. `id`가 존재하지 않을 때, `update`나 `delete`는 오류를 발생시키지만 `findUnique`는 `null`을 반환합니다. 이 동작을 통일하기 위해, `findUnique` 대신 **`findUniqueOrThrow`** 메소드를 사용합니다.

`findUniqueOrThrow`는 `id`에 해당하는 데이터를 찾지 못하면 `null`을 반환하는 대신, 위에서 정의한 `P2025` 오류를 발생시켜 `asyncHandler`가 일관되게 `404 Not Found` 응답을 보낼 수 있게 해줍니다.

---

### 4. 모든 라우트에 최종 에러 핸들러 적용하기

이제 완성된 `asyncHandler`와 `findUniqueOrThrow`를 모든 `User` 라우트에 적용합니다.

```javascript
// /app.js

// ... (asyncHandler 함수)

/* ========== users ========== */
app.get(
  '/users',
  asyncHandler(async (req, res) => {
    // ... (기존 코드와 동일)
  })
);

app.get(
  '/users/:id',
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    // findUnique 대신 findUniqueOrThrow를 사용합니다.
    const user = await prisma.user.findUniqueOrThrow({
      where: { id },
    });
    res.send(user);
  })
);

app.post(
  '/users',
  asyncHandler(async (req, res) => {
    assert(req.body, CreateUser);
    const user = await prisma.user.create({
      data: req.body,
    });
    res.status(201).send(user);
  })
);

app.patch(
  '/users/:id',
  asyncHandler(async (req, res) => {
    assert(req.body, PatchUser);
    const { id } = req.params;
    const user = await prisma.user.update({
      where: { id },
      data: req.body,
    });
    res.send(user);
  })
);

app.delete(
  '/users/:id',
  asyncHandler(async (req, res) => {
    const { id } = req.params;
    await prisma.user.delete({
      where: { id },
    });
    res.sendStatus(204);
  })
);

// ... (Product 라우트 및 서버 시작 코드)
```

### ✅ 최종 테스트

이제 잘못된 요청을 보내도 서버가 멈추지 않고, 우리가 설정한 상태 코드와 에러 메시지를 정확하게 응답하는 것을 확인할 수 있습니다.

- **유효성 검사 실패 시** (`POST /users`에 잘못된 이메일 전송)
  → `400 Bad Request`와 함께 `superstruct` 에러 메시지 응답
- **'Not Found' 오류 발생 시** (`GET /users/존재하지-않는-id`)
  → `404 Not Found`와 함께 `Cannot find given id.` 메시지 응답

이제 여러분의 API는 어떤 상황에서도 안정적으로 동작하는 강력한 에러 처리 기능을 갖추게 되었습니다\! 🎉
