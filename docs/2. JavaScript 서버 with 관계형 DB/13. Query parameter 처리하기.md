제공해주신 내용에 일부 수정이 있었습니다.

API 테스트 예시 중, 설명을 더 명확하게 다듬고 마지막 요청의 오타를 수정했습니다. 전체적인 개념 설명과 코드, 로직은 매우 훌륭하여, 수정한 부분을 중심으로 입문자분들이 더 쉽게 따라 할 수 있도록 전체 가이드를 완성했습니다.

---

## ⚙️ API에 날개 달기: 쿼리 파라미터 처리하기

지금까지 만든 `GET /users` 엔드포인트는 항상 모든 유저를 똑같은 순서로 반환합니다. 하지만 실제 서비스에서는 '최신순/오래된순 정렬'이나 '1페이지/2페이지 보기'처럼, 사용자가 원하는 조건에 맞춰 데이터를 다르게 보여줘야 할 때가 많습니다.

URL의 `?` 뒤에 오는 **쿼리 파라미터(Query Parameter)** 를 처리하면, 이처럼 유연하고 강력한 API를 만들 수 있습니다. `prisma.user.findMany()` 메소드의 다양한 옵션을 활용하여 **정렬(order)** 과 **페이지네이션(pagination)** 기능을 구현해 보겠습니다.

### 1. 라우트 핸들러 설계하기

`GET /users` 엔드포인트가 다음과 같은 쿼리 파라미터를 받을 수 있도록 코드를 수정해 보겠습니다.

- **`order`**: 정렬 순서. `'oldest'`일 경우 오래된순, 그 외에는 최신순(기본값).
- **`offset`**: 건너뛸 데이터 개수. (기본값: `0`)
- **`limit`**: 가져올 데이터 개수. (기본값: `10`)

---

### 2. 쿼리 파라미터 읽기 (기본값 설정)

먼저, `req.query`에서 각 파라미터를 추출합니다. **구조 분해 할당** 문법과 **기본값** 설정을 함께 사용하면, 쿼리 파라미터가 들어오지 않았을 때의 기본 동작을 아주 깔끔하게 정의할 수 있습니다.

```javascript
// /app.js
app.get('/users', async (req, res) => {
  // 쿼리 파라미터가 없으면 offset=0, limit=10, order='newest'가 기본으로 사용됩니다.
  const { offset = 0, limit = 10, order = 'newest' } = req.query;

  // ...
});
```

---

### 3. Prisma 쿼리 옵션 구현하기

이제 추출한 파라미터를 Prisma가 이해할 수 있는 `findMany` 옵션으로 변환합니다.

#### 페이지네이션 (Pagination)

`offset`과 `limit`은 '결과를 페이지처럼 나누어 보여주는' 페이지네이션 기능을 구현하는 데 사용됩니다.

- `offset` (건너뛸 개수) → Prisma의 **`skip`** 옵션
- `limit` (가져올 개수) → Prisma의 **`take`** 옵션

쿼리 파라미터는 항상 문자열(string)로 들어오기 때문에, 숫자(number)를 필요로 하는 `skip`과 `take` 옵션에 전달하기 전에 `parseInt()`로 변환해주는 것이 안전합니다.

#### 동적 정렬 (Dynamic Sorting)

`order` 값에 따라 다른 정렬 규칙을 적용해야 합니다. `switch` 문을 사용하면 다양한 정렬 옵션을 깔끔하게 처리할 수 있습니다.

- `order` 값 → Prisma의 **`orderBy`** 옵션

---

### ✅ 최종 코드

위 개념들을 모두 적용한 최종 코드는 다음과 같습니다.

```javascript
// /app.js
app.get('/users', async (req, res) => {
  const { offset = 0, limit = 10, order = 'newest' } = req.query;

  let orderBy;
  // order 값에 따라 orderBy 객체를 동적으로 설정합니다.
  switch (order) {
    case 'oldest':
      orderBy = { createdAt: 'asc' }; // 오래된순 (오름차순)
      break;
    case 'newest':
    default:
      orderBy = { createdAt: 'desc' }; // 최신순 (내림차순)
      break;
  }

  const users = await prisma.user.findMany({
    skip: parseInt(offset),
    take: parseInt(limit),
    orderBy: orderBy,
    // `orderBy: orderBy` 라고 작성해도 됨
  });

  res.send(users);
});
```

---

### 🧪 API 테스트하기

이제 다양한 쿼리 파라미터를 조합하여 API를 테스트해 봅시다.

#### 1\. 기본 요청 (최신순 10개)

```http
GET http://localhost:3000/users
```

→ `createdAt` 기준으로 내림차순(최신순) 정렬된 유저 데이터가 최대 10개 반환됩니다.

#### 2\. 오래된순 정렬

```http
GET http://localhost:3000/users?order=oldest
```

→ `createdAt` 기준으로 오름차순(오래된순) 정렬된 결과가 반환됩니다.

#### 3\. 페이지네이션

```http
GET http://localhost:3000/users?offset=2&limit=2
```

→ 전체 유저 중 처음 2명을 건너뛰고(`offset=2`), 그다음 2명만(`limit=2`) 가져옵니다. (즉, 3번째와 4번째 유저)

#### 4\. 모든 조건 조합하기

```http
GET http://localhost:3000/users?order=oldest&offset=1&limit=2
```

→ **오래된순**으로 정렬한 뒤, **첫 번째 유저를 건너뛰고**, 그다음 **2명의 유저**를 가져옵니다.

이처럼 쿼리 파라미터를 활용하면 하나의 엔드포인트로도 클라이언트에게 훨씬 더 풍부하고 유연한 데이터 조회 기능을 제공할 수 있습니다.
