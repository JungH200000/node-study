## 다양한 OAuth, OpenID 플로우

지금까지 OAuth 2.0의 가장 표준적인 방식인 **'인증 코드 승인(Authorization Code Grant)'** 흐름에 대해 배웠습니다. 하지만 OAuth에는 다른 방식들도 존재합니다.

이번 글에서는 그중 하나인 **'암시적 승인(Implicit Grant)'** 흐름을 살펴보고, **왜 이 방식이 현재는 권장되지 않는지**, 그리고 왜 우리가 배운 '인증 코드 승인' 방식이 더 안전한지에 대해 명확하게 알아보겠습니다.

---

### ✨ 더 간단해 보이는 방법: Implicit Flow란?

Implicit Flow는 과거 SPA(Single-Page Application) 초창기에, 브라우저에서 실행되는 자바스크립트가 직접 액세스 토큰을 발급받기 위해 고안된 방식입니다. 이름처럼(Implicit, 암시적) 중간 단계를 생략하여 더 간단해 보이는 것이 특징입니다.

### 두 방식의 결정적 차이

두 방식의 가장 큰 차이점은 **사용자 동의 후, 인가 서버가 프론트엔드에게 무엇을 돌려주느냐**에 있습니다.

- **인증 코드(Authorization Code) Flow (우리가 배운 방식)**

  1.  사용자가 구글에 로그인하고 동의하면,
  2.  구글은 프론트엔드에게 **`Authorization Code`(임시 허가증)** 를 전달합니다.
  3.  프론트엔드는 이 임시 허가증을 **백엔드**로 보냅니다.
  4.  **백엔드**가 자신의 `Client Secret`과 함께 임시 허가증을 구글에 보내 최종적으로 **`Access Token`** 을 발급받습니다.

- **암시적(Implicit) Flow**
  1.  사용자가 구글에 로그인하고 동의하면,
  2.  구글은 **`Access Token`(만능 열쇠)** 을 **프론트엔드에게 직접** 전달합니다.
  3.  중간 단계 없이 바로 액세스 토큰을 얻습니다.

---

### 🚨 Implicit Flow가 권장되지 않는 이유: '보안'

중간에 '임시 허가증'을 교환하는 번거로운 과정 없이 바로 '만능 열쇠'를 얻으니 훨씬 간단해 보이지만, 이 단순함이 심각한 보안 취약점을 만듭니다.

#### **위험 1: 민감한 토큰의 노출**

`Access Token`은 매우 민감한 정보입니다. Implicit Flow에서는 이 토큰이 **브라우저의 URL 주소창(리디렉션 URI의 일부)을 통해 프론트엔드로 직접 전달**됩니다. 이 과정에서 브라우저 방문 기록, 악성 브라우저 확장 프로그램, 또는 다른 스크립트(XSS 공격)에 의해 **토큰이 탈취될 위험이 매우 큽니다.**

#### **위험 2: 클라이언트 신원 위장**

프론트엔드 환경(브라우저)은 소스 코드가 모두 노출되어 있어 `Client Secret`과 같은 비밀 정보를 안전하게 저장할 수 없습니다. 따라서 Implicit Flow는 `Client Secret`을 사용하지 않습니다.

이는 **인가 서버 입장에서 액세스 토큰을 요청하는 클라이언트가 정말 '코드잇'이 맞는지 100% 확신할 수 없다**는 것을 의미합니다. 악의적인 사이트가 '코드잇'인 척 위장하여 토큰을 발급받으려 시도할 수도 있습니다.

---

### Authorization Code Flow는 어떻게 이 문제를 해결할까?

반면, 우리가 배운 Authorization Code Flow는 이러한 보안 문제를 해결합니다.

> **보안 창구에서 열쇠를 받는 것과 같아요! 🔒**
>
> 1.  프론트엔드(브라우저)는 밖에서 **'임시 출입증'(Authorization Code)** 만 받습니다. 이 출입증만으로는 아무것도 할 수 없습니다.
> 2.  이 출입증은 오직 **안전한 내부 통신망** 을 통해 **백엔드 서버(보안 창구)** 로 전달됩니다.
> 3.  백엔드 서버는 금고에 보관해 둔 자신의 **'직원 신분증'(`Client Secret`)** 과 함께 출입증을 인가 서버에 제시합니다.
> 4.  인가 서버는 출입증과 직원 신분증을 모두 확인한 뒤, 비로소 안전한 백엔드 서버에게만 **'만능 열쇠'(`Access Token`)** 를 내어줍니다.

이처럼 **중요한 액세스 토큰은 절대 브라우저에 직접 노출되지 않고**, 안전한 서버 간 통신을 통해서만 전달됩니다. `Client Secret`을 통해 클라이언트의 신원까지 확실히 증명하므로 훨씬 더 안전합니다.

---

### ✍️ 마무리하며

- **Implicit Flow**는 중간 과정 없이 프론트엔드에 직접 `Access Token`을 전달하여 구현이 간단해 보이지만, **토큰 탈취와 클라이언트 위장에 대한 심각한 보안 취약점**을 가지고 있습니다.
- **Authorization Code Flow**는 `Authorization Code`라는 중간 단계를 거치는 더 복잡한 방식이지만, `Access Token`이 브라우저에 노출되지 않고 `Client Secret`을 통해 클라이언트의 신원을 증명하므로 **훨씬 더 안전**합니다.
- 이러한 이유로, **OAuth 2.0의 최신 보안 모범 사례(Best Current Practice)에서는 Implicit Flow의 사용을 금지**하고 있으며, 모든 웹 애플리케이션과 네이티브 앱에서 **Authorization Code Flow(와 PKCE 확장)** 를 사용할 것을 강력히 권고하고 있습니다.
- 다른 몇 가지 플로우(Hybrid, Client-Credentials 등)도 존재하지만, 대부분의 상황에서는 **Authorization Code Flow가 가장 표준적이고 안전한 선택**이라는 점을 기억해 주세요.
- [공식 문서](https://oauth.net/2/grant-types/)
