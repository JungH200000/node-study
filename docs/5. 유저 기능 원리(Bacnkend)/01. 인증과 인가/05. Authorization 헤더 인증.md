## 로그인 상태 유지의 비밀 2편: 토큰 인증과 Authorization 헤더 📜

지난 글에서는 브라우저가 자동으로 관리해주는 '쿠키'를 이용한 인증 방식을 알아봤습니다. 하지만 때로는 이 '자동' 기능 대신, 개발자가 직접 인증 과정을 제어하고 싶을 때가 있습니다.

이번 글에서는 클라이언트가 **인증서 역할을 하는 '토큰(Token)'을 직접 관리**하고, **`Authorization` 헤더**를 통해 서버에 수동으로 전송하는 **토큰 기반 인증** 방식에 대해 알아보겠습니다.

---

### 토큰 기반 인증(Token-based Authentication)이란?

토큰 기반 인증은 쿠키의 자동화된 방식과 달리, **클라이언트의 자바스크립트 코드가 인증의 전 과정을 직접 책임지는 방식**입니다. 로그인 시 서버로부터 받은 '출입증(토큰)'을 클라이언트가 직접 저장하고, 필요할 때마다 꺼내서 서버에 보여주는 것이죠.

---

### 토큰 인증은 어떻게 동작할까요? (단계별 흐름)

#### **1단계: 서버의 '출입증(토큰)' 발급**

사용자가 성공적으로 로그인하면, 서버는 `Set-Cookie` 헤더가 아닌 **응답 본문(Body)에 토큰을 담아** 클라이언트에게 전달합니다.

```json
HTTP/1.1 200 OK
Content-Type: application/json

{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywiaWF0IjoxNjc..."
}
```

---

#### **2단계: 클라이언트의 '출입증' 수동 보관 (feat. 로컬 스토리지)**

`Set-Cookie` 헤더가 없으므로 브라우저는 아무것도 자동으로 저장하지 않습니다. 이제 **개발자가 작성한 자바스크립트 코드가 직접** 응답 본문에서 토큰을 꺼내 안전한 곳에 저장해야 합니다.

이때 주로 사용되는 브라우저의 저장 공간이 바로 **로컬 스토리지(Local Storage)** 입니다. 쿠키와 마찬가지로 브라우저에 데이터를 저장할 수 있지만, 자바스크립트를 통해서만 제어할 수 있는 공간입니다.

```javascript
// 응답으로 받은 토큰을 'accessToken'이라는 이름으로 로컬 스토리지에 저장
localStorage.setItem('accessToken', 'eyJhbGciOiJIUzI1Ni...');
```

---

#### **3단계: 매 요청마다 '출입증' 제시 (`Authorization` 헤더)**

인증이 필요한 API를 요청할 때, 클라이언트는 **자바스크립트 코드를 통해** 로컬 스토리지에서 토큰을 다시 꺼내와 `Authorization` 요청 헤더에 담아 보내야 합니다.

이때 토큰은 보통 **`Bearer`** 라는 접두사와 함께 전송됩니다. 이는 "이 토큰을 소지한(Bearer) 사람에게는 접근을 허용하라"는 의미를 지닌 표준 방식입니다.

```http
DELETE https://example.com/members/3
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywiaWF0IjoxNjc...
```

서버는 이 `Authorization` 헤더를 확인하고, `Bearer` 뒤에 오는 토큰 값을 검증하여 사용자가 누구인지 확인합니다.

---

### 왜 쿠키 대신 토큰을 사용할까요? (장점)

코드를 더 많이 작성해야 하는 번거로움에도 불구하고 토큰 방식을 사용하는 데에는 분명한 장점들이 있습니다.

#### **장점 1: 뛰어난 제어권과 유연성**

모든 요청에 쿠키가 자동으로 실려 가는 것과 달리, 토큰은 개발자가 **필요한 요청에만 선택적으로** 담아 보낼 수 있습니다. 이는 CSRF와 같이 쿠키의 자동 전송 특징을 악용하는 일부 보안 공격을 예방하는 데 도움이 되며, 여러 종류의 토큰을 상황에 맞게 골라 쓰는 등 더 유연한 제어가 가능해집니다.

#### **장점 2: 도메인의 제약으로부터 자유로움**

쿠키는 기본적으로 발급된 도메인에서만 사용할 수 있지만, `Authorization` 헤더는 어떤 도메인이든 상관없이 자유롭게 보낼 수 있습니다.

이는 웹사이트(`example.com`), 모바일 앱, 다른 회사의 서버 등 **다양한 클라이언트 환경에서 동일한 인증 방식을 사용**해야 하는 현대적인 API 환경에 매우 적합합니다.

---

### ⚠️ 주의사항: 비밀번호는 절대 저장 금지\!

어떤 인증 방식을 사용하든, **사용자의 실제 비밀번호와 같은 민감한 정보는 절대로 쿠키나 로컬 스토리지에 저장해서는 안 됩니다.** 만약 이 정보가 유출된다면, 다른 서비스의 계정까지 연쇄적으로 탈취당하는 등 걷잡을 수 없는 보안 문제로 이어질 수 있습니다.

---

### ✍️ 마무리하며

- **토큰 기반 인증**은 서버가 발급한 토큰을 **클라이언트가 직접(수동으로) 저장하고 관리**하는 방식입니다.
- 클라이언트는 로그인 시 응답 본문으로 토큰을 받아 **로컬 스토리지** 등에 저장합니다.
- 이후 요청 시에는 저장된 토큰을 읽어와 **`Authorization: Bearer <토큰>`** 형식의 헤더에 담아 전송합니다.
- 이 방식은 쿠키보다 구현이 조금 더 복잡하지만, **제어권이 높고 다양한 클라이언트 환경에 적용하기 용이하다**는 강력한 장점을 가집ed.
