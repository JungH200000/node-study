### 🤔 '인가(Authorization)' 헤더로 '인증(Authentication)'을?

우리는 바로 이전 글들에서 **'인증'** 과 **'인가'** 가 서로 다른 개념이라고 강조했습니다.

- **인증(Authentication)**: 당신이 **누구인지** 확인하는 것 (예: 로그인)
- **인가(Authorization)**: 당신이 **무엇을 할 수 있는지** 확인하는 것 (예: 권한 확인)

그런데 우리는 토큰 기반 '인증'을 배울 때, 아래와 같이 `Authorization`(인가)이라는 이름의 헤더를 사용했습니다.

```http
DELETE http://www.example.com/api/members/1/
Authorization: Bearer <token>
```

'인증'을 위한 정보를 '인가'라는 이름의 헤더에 담아 보낸다니, 조금 이상하게 느껴지지 않으셨나요? 여러분이 헷갈리는 것은 지극히 정상입니다\!

---

### 이름이 잘못 지어졌어요 (feat. 역사)

결론부터 말하면, **오늘날의 엄격한 기준으로 보면 헤더 이름이 잘못 지어진 것이 맞습니다.**

웹 표준을 정의하는 [공식 문서(RFC 7235)](https://www.google.com/search?q=https://www.rfc-editor.org/rfc/rfc7235%23section-4.2)를 살펴보면, `Authorization` 헤더는 서버에 사용자의 **'인증' 자격증명을 보내기 위한 헤더**라고 명확히 정의되어 있습니다.

정확한 이유는 알 수 없지만, 약 20여 년 전 이 표준이 처음 만들어질 당시에는 지금처럼 '인증'과 '인가'라는 두 단어를 엄격하게 구분하지 않았거나, "어떤 요청을 인가하려면 당연히 인증 정보가 필요하다"는 생각에서 이름을 지었을 것이라고 추측할 수 있습니다.

> **💾 '저장' 아이콘이 플로피 디스크인 이유와 같아요\!**
>
> 요즘 컴퓨터를 배운 세대는 플로피 디스크를 본 적도 없지만, 우리는 여전히 디스크 모양의 아이콘을 누르면 '저장'이 될 것이라고 알고 있습니다. 역사적인 이유로 굳어진 약속이죠. `Authorization` 헤더의 이름도 이와 비슷한 경우라고 생각할 수 있습니다.

---

### 왜 그냥 계속 사용하나요?

이렇게 헷갈리는 이름을 왜 바로잡지 않고 계속 사용하는 걸까요?

가장 큰 이유는 **하위 호환성(Backward Compatibility)** 때문입니다. 이미 전 세계의 수많은 웹사이트와 API, 서버, 클라이언트 라이브러리가 `Authorization` 헤더를 '인증'의 의미로 사용하고 있습니다. 만약 이 헤더의 이름을 `Authentication`으로 바꾼다면, 기존에 만들어진 거의 모든 시스템이 망가지는 대혼란이 발생할 것입니다.

이런 복잡한 문제를 감수하면서까지 이름 하나를 바꾸는 것은 이득보다 손실이 훨씬 크기 때문에, 우리는 이 역사적인 '이름 실수'를 하나의 **관례(Convention)** 로 받아들이고 계속 사용하고 있는 것입니다.

---

### ✍️ 마무리하며

- **`Authorization`** 헤더는 이름과 달리, **'인가(Authorization)'가 아닌 '인증(Authentication)'** 정보를 서버에 전달하기 위한 헤더입니다.
- 이는 과거 웹 표준이 제정될 때 만들어진 **역사적인 이름**이며, 오늘날의 엄격한 정의와는 다소 차이가 있습니다.
- **하위 호환성** 문제 때문에 이 이름은 바뀌지 않고 계속 사용되고 있으므로, 우리는 이 관례를 이해하고 받아들이면 됩니다.

이제 `Authorization` 헤더를 마주쳤을 때 "이건 인가 정보를 담는 곳"이 아니라, **"아, 이건 사용자의 신원을 증명하는 토큰 같은 인증 정보를 담는 곳이구나\!"** 라고 자신 있게 생각하시면 됩니다.
