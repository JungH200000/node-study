## 내 쿠키는 소중하니까: 쿠키를 안전하게 지키는 3가지 방패 🛡️

쿠키는 사용자 인증뿐만 아니라, 검색 기록, 장바구니, 다크 모드 설정 유지 등 개인화된 웹 경험을 제공하는 데 매우 유용하게 쓰입니다.

하지만 이렇게 편리한 쿠키가 만약 다른 사람에게 탈취되거나 악용된다면 심각한 보안 문제로 이어질 수 있습니다. 특히 사용자의 신원을 증명하는 인증 쿠키가 유출된다면 더욱 그렇죠.

다행히도, 우리는 몇 가지 간단한 설정을 통해 쿠키를 훨씬 더 안전하게 만들 수 있습니다. 쿠키를 위한 3가지 보안 방패, `Secure`, `HttpOnly`, `SameSite`에 대해 알아봅시다.

---

### 방패 1: `Secure` - 암호화된 길로만 다니기

`Secure` 속성이 설정된 쿠키는 **암호화된 연결, 즉 `HTTPS` 프로토콜을 사용할 때만** 서버로 전송됩니다.

만약 `HTTP` 연결을 사용한다면, 중간에서 누군가 네트워크 통신을 엿보았을 때 쿠키 정보가 그대로 노출될 수 있습니다. `Secure` 속성은 마치 "이 중요한 정보는 반드시 보안 요원이 호위하는 안전한 길(`HTTPS`)로만 전달해야 해\!"라고 지정하는 것과 같습니다.

```response
Set-Cookie: cookie_name=cookie_value; Secure;
```

---

### 방패 2: `HttpOnly` - 자바스크립트의 접근을 막기

`HttpOnly` 속성이 설정된 쿠키는 **웹 브라우저의 자바스크립트 코드(`document.cookie`)를 통해 접근할 수 없게 됩니다.** 오직 브라우저의 HTTP 통신을 통해서만 서버로 전송될 뿐이죠.

이는 악성 스크립트가 웹사이트에 주입되었을 때, 사용자의 인증 쿠키와 같은 민감한 정보를 직접 훔쳐가는 **XSS(Cross-Site Scripting) 공격을 방어**하는 데 매우 효과적입니다.

```response
Set-Cookie: cookie_name=cookie_value; Secure; HttpOnly;
```

---

### 방패 3: `SameSite` - 아무 데나 따라가지 않기 (CSRF 방어)

`SameSite` 속성은 다른 웹사이트의 요청에 우리 사이트의 쿠키가 실려 가는 것을 막아주는 가장 중요한 보안 설정 중 하나입니다. 이를 통해 **CSRF(Cross-Site Request Forgery) 공격**을 효과적으로 방어할 수 있습니다.

#### **CSRF 공격이란?**

사용자가 `A.com`에 로그인하여 쿠키를 발급받은 상태에서, 해커가 만들어 둔 악성 사이트 `B.com`을 방문했다고 가정해 봅시다. 만약 `B.com`에 `A.com`의 비밀번호를 변경하는 요청을 보내는 링크나 버튼이 숨겨져 있다면? 사용자가 무심코 이를 클릭하는 순간, 브라우저는 `A.com`으로 요청을 보내면서 **자신도 모르게 `A.com`의 로그인 쿠키를 함께 실어 보내게 됩니다.** `A.com` 서버는 정상적인 사용자가 보낸 요청이라고 착각하여 비밀번호를 변경해버릴 수 있죠.

`SameSite` 속성은 바로 이런 상황을 막기 위해, 쿠키가 어떤 상황에서 전송되어야 하는지를 정합니다.

#### **`SameSite` 설정값 알아보기**

- **`SameSite=Strict`**
  가장 강력한 설정입니다. 쿠키는 **요청이 시작된 곳과 도착지가 완전히 동일한 도메인일 때만** 전송됩니다. 즉, `A.com`에서 `A.com`으로 요청할 때만 쿠키가 갑니다.

  - **단점**: 보안성은 가장 높지만, 다른 사이트(이메일, SNS)에 있는 링크를 클릭해서 우리 사이트로 들어올 때도 쿠키가 전송되지 않아, 사용자가 로그아웃된 것처럼 보일 수 있습니다.

- **`SameSite=Lax`**
  `Strict`보다 약간 완화된 설정으로, 대부분의 브라우저에서 기본값으로 사용됩니다. **링크를 클릭하거나 주소창에 직접 주소를 입력하는 등, 사용자가 직접 다른 사이트로 이동할 때는 쿠키를 전송**합니다.

  - 하지만 `<img>` 태그나 `<iframe>`처럼 다른 웹사이트에 우리 사이트의 리소스가 포함되어 요청이 발생할 때는 쿠키를 보내지 않아 대부분의 CSRF 공격을 막을 수 있습니다.

- **`SameSite=None`**
  과거의 방식처럼, 모든 크로스사이트 요청에 쿠키를 전부 전송합니다.

  - **주의\!**: 이 설정을 사용하려면, 반드시 `Secure` 속성을 함께 설정해야만 브라우저가 쿠키를 정상적으로 저장하고 사용합니다. (`SameSite=None; Secure`)

---

### 🛡️ 종합 예시: 모든 방패 장착하기

실제 `Set-Cookie` 헤더는 이 속성들을 조합하여 다음과 같은 모습이 됩니다.

```http
Set-Cookie: access_token=ey...; Expires=Sun, 20 Mar 2025 05:16:59 GMT; Secure; HttpOnly; SameSite=Lax; Path=/
```

---

### ✍️ 마무리하며

쿠키는 웹을 편리하게 만들어주는 강력한 도구이지만, 보안 설정을 제대로 하지 않으면 심각한 위협이 될 수 있습니다.

- **`Secure`**: 통신을 암호화하여 중간자 공격을 방지합니다.
- **`HttpOnly`**: 스크립트 탈취(XSS) 공격으로부터 쿠키를 보호합니다.
- **`SameSite`**: 다른 사이트를 이용한 요청 위조(CSRF) 공격을 방지합니다.

이 세 가지 방패를 올바르게 사용하여 사용자의 소중한 정보를 안전하게 지키는 것이야말로, 신뢰할 수 있는 웹 서비스를 만드는 개발자의 중요한 책임입니다.
