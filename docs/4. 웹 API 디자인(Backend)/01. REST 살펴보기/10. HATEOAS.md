## API가 다음 할 일을 알려준다? HATEOAS 완벽 이해 🗺️

REST의 '일관된 인터페이스'를 구성하는 마지막 원칙, **HATEOAS(헤이티오스)** 에 대해 알아볼 시간입니다. 이름이 조금 길고 복잡해 보이지만, 개념을 알고 나면 웹의 동작 방식과 매우 닮아있다는 것을 알게 될 거예요.

> **HATEOAS란?**
>
> **H**ypermedia **A**s **T**he **E**ngine **O**f **A**pplication **S**tate의 약자로, **"애플리케이션의 상태는 하이퍼미디어를 통해 전이되어야 한다"** 는 의미입니다.
>
> 아주 쉽게 말해, 서버가 클라이언트에게 응답을 보낼 때, **"현재 이 데이터와 관련해서 다음에는 이런 일들을 할 수 있어"** 라는 정보를 함께 알려주는 것입니다.

---

### 왜 HATEOAS가 필요한가요? (문제점)

우리가 흔히 보는 API 응답은 다음과 같은 형태입니다.

- **HATEOAS가 적용되지 않은 응답**

  ```json
  {
    "id": 1,
    "name": "Chung"
  }
  ```

이 응답은 ID가 1이고 이름이 Chung이라는 '데이터'만 알려줄 뿐, 이 멤버 정보를 수정하거나 삭제하려면 어떤 주소(`URI`)로 요청을 보내야 하는지에 대한 정보는 전혀 없습니다. 클라이언트 개발자는 API 문서를 뒤져서 다음 행동에 필요한 URI를 직접 찾아내고 코드에 하드코딩해야 합니다.

---

### HATEOAS 구현 방법 2가지

HATEOAS 원칙은 바로 이 문제를 해결합니다. 응답 메시지 안에 **다음 행동으로 이어질 수 있는 링크(하이퍼미디어)를 포함**하여, 클라이언트가 이 링크들을 따라다니며 API와 동적으로 상호작용할 수 있게 만듭니다.

#### 방법 1: 응답 본문에 링크 포함하기 (HAL 표준)

가장 대표적인 방법은 응답 본문(Body)에 다음 행동에 대한 링크 정보를 함께 포함하는 것입니다. 이때 **HAL(Hypertext Application Language)** 이라는 표준 데이터 형식을 사용하면 일관성을 유지하기 좋습니다.

HAL은 기존 데이터(**리소스**)와 함께 `_links_`라는 키워드로 **링크** 정보를 표현하는 JSON 기반의 미디어 타입(`application/hal+json`)입니다.

- **HAL을 적용한 응답 예시**

  ```json
  {
    "id": 1, // 리소스: 멤버의 ID
    "name": "Chung", // 리소스: 멤버의 이름
    "_links_": {
      // 링크: 이 리소스와 관련된 작업들
      "self": {
        // rel(관계): 'self'는 이 리소스 자신을 가리킴
        "href": "https://example.com/members/1", // href: 링크의 목적지 주소
        "method": "GET"
      },
      "update": {
        // rel(관계): 'update'는 리소스를 수정하는 작업
        "href": "https://example.com/members/1",
        "method": "PATCH"
      }
    }
  }
  ```

이제 클라이언트는 응답에 포함된 `_links_` 객체를 보고 "아, 이 멤버 정보를 수정하려면 `update` 링크의 `href` 주소로 `PATCH` 요청을 보내면 되는구나\!" 하고 즉시 알 수 있습니다.

#### 방법 2: Link 헤더 사용하기

응답 본문을 깔끔하게 유지하고 싶다면, **HTTP `Link` 헤더**를 사용하는 방법도 있습니다.

- **`Link` 헤더를 사용한 응답 예시**

  ```http
  HTTP/1.1 200 OK
  Content-Type: application/json
  Link: <https://example.com/members/1>; rel="previous",
        <https://example.com/members/3>; rel="next"

  {
    "id": 2,
    "name": "Hyun"
  }
  ```

이 응답은 ID가 2번인 멤버 정보를 보여주면서, `Link` 헤더를 통해 **"이전 멤버(previous)는 1번, 다음 멤버(next)는 3번이야"** 라는 페이지네이션 정보를 알려줍니다. 클라이언트는 이 헤더 정보를 해석하여 '이전', '다음' 버튼 기능을 구현할 수 있습니다.

---

### HTML의 `<a>` 태그를 떠올려보세요\!

사실 HATEOAS는 우리가 매일 사용하는 웹의 동작 방식과 똑같습니다.

> **`<a href="https://example.com/members/3">next</a>`**

우리는 웹서핑을 할 때 다음 페이지로 이동하기 위해 주소창에 URL을 직접 입력하지 않습니다. 대신 페이지에 있는 '다음'이나 '수정' 같은 **링크(`<a>` 태그)** 를 클릭하죠. 이 링크가 바로 현재 페이지의 상태에서 다음 상태로 넘어갈 수 있게 해주는 **하이퍼미디어**입니다.

HATEOAS가 잘 구현된 API는, 클라이언트가 마치 사람이 웹사이트를 탐색하듯, 최초 진입점 URI만 알면 그 이후의 모든 상호작용을 응답에 포함된 링크들을 따라다니며 수행할 수 있게 됩니다.

---

### ✍️ 핵심 요약

- **HATEOAS**는 서버 응답에 **다음 행동으로 이어질 수 있는 관련 링크**들을 포함하여, 클라이언트가 동적으로 API와 상호작용할 수 있게 만드는 REST 원칙입니다.
- 목표는 클라이언트가 API의 전체 구조를 미리 알 필요 없이, 마치 **웹 서핑을 하듯 링크를 따라 API를 탐색**할 수 있게 하는 것입니다.
- 구현 방법에는 응답 본문에 링크를 담는 **HAL 표준**을 사용하거나, HTTP **`Link` 헤더**를 사용하는 방법이 있습니다.
- 이 원칙은 우리가 웹 페이지에서 **`<a>` 태그를 클릭하여 다른 페이지로 이동**하는 것과 동일한 개념입니다.
